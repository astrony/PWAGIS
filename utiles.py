# -*- coding: utf-8 -*-
"""
/***************************************************************************
 pwagis
                                 A QGIS plugin
 PWA
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-15
        git sha              : $Format:%H$
        copyright            : (C) 2024 by PWA
        email                : pwa
 ***************************************************************************/
"""
from qgis.core import QgsVectorLayer, QgsProject, QgsApplication
from qgis.PyQt.QtWidgets import QMessageBox
import os.path
import os
import json
import requests
import shutil
import configparser
import urllib.parse
import pandas as pd
import sys
import subprocess
from urllib.request import urlopen
from ulid import ULID
from datetime import datetime

def checkNetConnection():
    try:
        urlopen('http://www.google.com', timeout=10)
        print("Net id ok")
        return True
    except Exception as err:
        pass
    return False


def checkServer():
    try:
        urlopen('https://gisdb.pwa.co.th/management/signin', timeout=10)

        return True
    except Exception as err:
        pass
    return False


def current_path():
    new_plugin_dir = os.path.dirname(__file__)
    return new_plugin_dir


def logins(self, host, email, password):
    if checkNetConnection() is True:
        if checkServer() is True:
            url = host + '/managements/1.0/login'
            payload = 'grant_type=password&accountType=email&username=' + email + '&password=' + password
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
            response = requests.request("POST", url, headers=headers, data=payload.encode('utf-8'))
            if response.status_code == 200:
                response = response.json()
                token = response['accessToken']
                refreshToken = response['refreshToken']
                self.token = token
                self.refreshToken = refreshToken
                update_ini(self)
            else:
                return "error", "error"
        else:
            message = "Can not connect to server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
            return "error", "error"
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return "error", "error"

def login_new(self, user, password):

    url = "https://gisapp.pwa.co.th/api/1.0/login"

    encode_password = urllib.parse.unquote(password)
    # payload = 'username=' + user + '&password=' + encode_password
    payload = {
        "username": user,
        "password": encode_password
    }
    
    print(self.nonpwa)
    if self.nonpwa is True:
        print("nonpwa")
        url = self.baseUrl + "/api/2.0/login"
        payload = 'grant_type=password&accountType=email&username=' + user + '&password=' + encode_password

    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }

    response = requests.request("POST", url, headers=headers, data=payload)
    if response.status_code == 200:
        response = response.json()
        token = response['accessToken']
        refreshToken = response['refreshToken']
        group = response['user']['group']['id']
        userId = response['user']['id']
        self.userId = userId
        self.token_new = token
        self.refreshToken_new = refreshToken
        self.config.set('settings', 'refreshtoken_new', str(self.refreshToken_new))
        with open(self.configpath, 'w') as configfile:
            self.config.write(configfile)
        self.refreshToken_new = self.config.get('settings', 'refreshtoken_new')
        update_token_new(self)
        # message = "login success"
        # self.iface.messageBar().pushMessage("Information  ", message, level=0, duration=3)
        return token, refreshToken, group
    else:
        print(str(response.status_code))
        message = "Can not login to server"
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        self.dockwidget.loginBtn.setEnabled(True)
        return "error", "error", "error"


def update_ini(self):
    if not self.refreshToken == "error":
        self.config.set('settings', 'refreshtoken', str(self.refreshToken))
        self.config.set('settings', 'token', str(self.token))
        with open(self.configpath, 'w') as configfile:
            self.config.write(configfile)
        self.refreshToken = self.config.get('settings', 'refreshtoken')
        self.token = self.config.get('settings', 'token')


def update_token_new(self):
    if not self.token_new == "error":
        self.config.set('settings', 'token_new', str(self.token_new))
        with open(self.configpath, 'w') as configfile:
            self.config.write(configfile)
        self.token_new = self.config.get('settings', 'token_new')


def update_current_branch(self, pwa_office_code):
    self.currentbranch = pwa_office_code[1]
    if not self.currentbranch == "error":
        self.config.set('settings', 'currentbranch', str(self.currentbranch))
        with open(self.configpath, 'w') as configfile:
            self.config.write(configfile)
        self.currentbranch = self.config.get('settings', 'currentbranch')


def update_current_district(self, pwa_office_code):
    self.currentdistrict = pwa_office_code[0]
    if not self.currentdistrict == "error":
        self.config.set('settings', 'currentdistrict', str(self.currentdistrict))
        with open(self.configpath, 'w') as configfile:
            self.config.write(configfile)
        self.currentdistrict = self.config.get('settings', 'currentdistrict')


def logout(self, host):
    status_code = "err"
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/logout"
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("POST", url, headers=headers, data=payload)
            # success response.status_code == 204:
            self.token = ''
            status_code = response.status_code
        return status_code
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return status_code


def refresh_token(self):
    if checkNetConnection() is True:
        url = self.host + "/managements/1.0/token"
        payload = 'grant_type=refresh_token&refresh_token=' + self.refreshToken
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        response = requests.request("POST", url, headers=headers, data=payload)

        if response.status_code == 200:
            response = response.json()
            token = response['accessToken']
            refreshToken = response['refreshToken']
            self.token = token
            self.refreshToken = refreshToken
            update_ini(self)
            o_status = "0"
        else:
            o_status = "1"
        return o_status
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return "err"


def CalculateBB(self):
    xmin = self.iface.mapCanvas().extent().xMinimum()
    xmax = self.iface.mapCanvas().extent().xMaximum()
    ymin = self.iface.mapCanvas().extent().yMinimum()
    ymax = self.iface.mapCanvas().extent().yMaximum()
    bb1 = str(xmin) + "," + str(ymin) + "," + str(xmax) + "," + str(ymax)
    bb = str(bb1)
    return bb


def removeAllLayer(self, groupName):
    # groupName = "B" + str(self.currentbranch) + "_Baselayer"
    root = QgsProject.instance().layerTreeRoot()
    group = root.findGroup(groupName)
    if not group is None:
        for child in group.children():
            dump = child.dump()
            id = dump.split("=")[-1].strip()
            QgsProject.instance().removeMapLayer(id)
        root.removeChildNode(group)


def removeGroup(self, groupName):
    root = QgsProject.instance().layerTreeRoot()
    group = root.findGroup(groupName)
    if not group is None:
        layers = group.findLayers()
        for layer in layers:
            QgsProject.instance().removeMapLayer(layer.layerId())
        root.removeChildNode(group)


def find_amount_layer(self, groupName):
    # remove Group
    # groupName = "B" + str(self.currentbranch) + "_Baselayer"
    root = QgsProject.instance().layerTreeRoot()
    group = root.findGroup(groupName)
    root.removeChildNode(group)

    layer = QgsProject.instance().mapLayers().values()  # Amount of Layer in map
    QgsProject.instance().removeAllMapLayers()  # Remove all Layer
    return str((len(layer)))


def retrieveGroup(self):
    userGroup = self.userGroup
    pwaCode = ""
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/groups/" + userGroup
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)

            if response.status_code == 200:
                data = response.json()
                pwaCode = data["properties"]["pwaCode"]
            else:
                message = "Can not get user group from server"
                self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
            return pwaCode
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def checkUserGroup(self, res):
    userType = ""
    if res[2] == "0" and res[3] == "0":
        userType = "Center"
    else:
        if res[5] == "0" and res[6] == "0":
            userType = "District"
        else:
            userType = "Branch"
    return userType


def show_District(self, data, districtCode):
    self.dlg1.districtCombo.clear()
    numberMatch = 0
    pwaDistrictCode = ""
    pwaDistrictName = ""
    if len(data) > 0:
        numberMatch = data["numberMatch"]
    if numberMatch > 0:
        for i in range(len(data["districts"])):
            pwaDistrictCode = data["districts"][i]["pwaCode"]
            pwaDistrictName = data["districts"][i]["pwaName"]
            if pwaDistrictCode == districtCode:
                self.dlg1.districtCombo.addItem(str(pwaDistrictName))
    return pwaDistrictCode, pwaDistrictName


def ShowAllBranch(self, data):
    if data is None:
        data = []
    branchList = []
    #branchCode = []
    numberMatch = 0
    pwaBranchCode = ""
    districtCode = ""

    if len(data) > 0:
        numberMatch = data["numberMatch"]
    if numberMatch > 0:
        self.dlg1.branchCombo.clear()
        for i in range(len(data["branches"])):
            pwaBranchCode = data["branches"][i]["pwaCode"]
            pwaBranchName = data["branches"][i]["pwaName"]
            districtCode = data["branches"][i]["districtCode"]
            branchList.append(pwaBranchName)
            #branchCode.append(pwaBranchCode)
            self.dlg1.branchCombo.addItem(str(pwaBranchName))
    return branchList, pwaBranchCode, districtCode#, branchCode


def getBranch(self, branchCode):
    # print(str(branchCode))
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/pwa-branches?limit=0&pwaCode=" + str(branchCode)
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            data = response.json()
            return data
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def show_Branch(self, data, pwaCode):
    self.dlg1.branchCombo.clear()
    numberMatch = 0
    if len(data) > 0:
        numberMatch = data["numberMatch"]
    if numberMatch > 0:
        for i in range(len(data["branches"])):
            pwaBranchCode = data["branches"][i]["pwaCode"]
            pwaBranchName = data["branches"][i]["pwaName"]
            if pwaBranchCode == pwaCode:
                self.dlg1.branchCombo.addItem(str(pwaBranchName))
                return pwaBranchName


def listAllDistrict(self):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/pwa-districts?sort=districtNo:asc"
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            data = response.json()
            return data
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def listAllBranch(self, districtNo, userType):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            if userType == "Center":
                url = self.baseUrl + "/api/2.0/resources/references/pwa-branches?districtNo=" + str(districtNo) + "&limit=0"
            elif userType == "District":
                url = self.baseUrl + "/api/2.0/resources/references/pwa-branches?districtCode=" + str(districtNo) + "&limit=0"
            elif userType == "Branch":
                url = self.baseUrl + "/api/2.0/resources/references/pwa-branches?districtCode=" + str(districtNo) + "&limit=0"
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            data = response.json()
            return data
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def list_district(self, data):
    self.dlg1.districtCombo.clear()
    districtList = []
    numberMatch = 0
    if len(data) > 0:
        numberMatch = data["numberMatch"]
    if numberMatch > 0:
        self.dlg1.districtCombo.clear()
        for i in range(len(data["districts"])):
            firstPwaDistrictCode = data["districts"][0]["pwaCode"]
            pwaDistrictName = data["districts"][i]["pwaName"]
            districtList.append(pwaDistrictName)
            self.dlg1.districtCombo.addItem(str(pwaDistrictName))
    return districtList, firstPwaDistrictCode


def list_branch(self, districtNo):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/pwa-branches?districtNo=" + str(districtNo) + "&limit=0"
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            data = response.json()
            return data
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def get_district_branch_code(self):
    pwa_office_code = []
    districtNo = self.districtCode
    pwaName = self.dlg1.branchCombo.currentText()
    branchIndex = self.dlg1.branchCombo.currentIndex()
    districtCode = ""
    branchCode = ""
    #tempPwaCode = self.tem_branchCode[branchIndex]
    url = self.baseUrl + "/api/2.0/resources/references/pwa-branches?limit=0&pwaName=" + str(pwaName) + "*"
    #url = self.baseUrl + "/api/2.0/resources/references/pwa-branches?limit=0&pwaCode=" + str(tempPwaCode)
    payload = {}
    headers = {
        'Authorization': 'Bearer ' + self.token_new
    }
    response = requests.request("GET", url, headers=headers, data=payload)
    data = response.json()
    numberMatch = 0
    if len(data) > 0:
        numberMatch = data["numberMatch"]
    if numberMatch > 0:
        districtCode = data["branches"][0]["districtCode"]
        branchCode = data["branches"][0]["pwaCode"]
        pwa_office_code.append(districtCode)
        pwa_office_code.append(branchCode)
    return pwa_office_code


def get_tile(self, collectionid_list):
    collectionId = collectionid_list


def clear_layer_combo(self):
    self.dockwidget.meterComboBox.clear()
    self.dockwidget.valveComboBox.clear()
    self.dockwidget.firehydrantComboBox.clear()
    self.dockwidget.leakpointComboBox.clear()
    self.dockwidget.pipeComboBox.clear()
    self.dockwidget.pwa_waterworksComboBox.clear()
    self.dockwidget.bldgComboBox.clear()
    self.dockwidget.nrw_meterComboBox.clear()
    self.dockwidget.structComboBox.clear()
    self.dockwidget.step_testComboBox.clear()
    self.dockwidget.pipe_servComboBox.clear()
    self.dockwidget.dma_boundaryComboBox.clear()
    self.dockwidget.attributeCombo.clear()
    self.dockwidget.resultTable.setRowCount(0)
    self.dockwidget.mGroupBox_2.hide()
    self.dockwidget.resultTable.horizontalHeader().setVisible(False)


def when_logout(self):
    # Delete style folder and create new
    dir_path = os.path.join(self.plugin_dir, "style")
    shutil.rmtree(dir_path)
    os.mkdir(dir_path)

    self.dockwidget.loginBtn.setEnabled(1)
    self.dockwidget.username.setReadOnly(0)
    self.dockwidget.password.setReadOnly(0)
    self.dockwidget.logoutBtn.setEnabled(0)
    self.dlg1.branchCombo.clear()
    self.dlg1.districtCombo.clear()
    self.dockwidget.notiFilterCombo.clear()

    self.dockwidget.branch_label.setText("สาขาที่ใช้งาน : ")

    self.dockwidget.tabWidget.setTabEnabled(0, False)
    self.dockwidget.tabWidget.setTabEnabled(1, False)
    self.dockwidget.tabWidget.setTabEnabled(2, False)
    self.dockwidget.tabWidget.setTabEnabled(3, False)
    self.dockwidget.tabWidget.setTabEnabled(4, False)
    self.dockwidget.tabWidget.setTabEnabled(5, False)

    self.dockwidget.changeDepartmentBnt.setEnabled(0)

    self.dockwidget.tabWidget.setCurrentIndex(6)

    # Set home button Enable
    self.dockwidget.homeBtn.setEnabled(0)

    # Edit Set Disable radio group unsuccessful
    self.dockwidget.unsuccess_group.setEnabled(0)

    # Set icon pipe project disable
    self.new_project.setEnabled(False)

    # Set nonpwa not check
    self.dockwidget.checkNonpwa.setChecked(False)
    self.dockwidget.checkNonpwa.setEnabled(1)

    # Cosmetic
    self.dockwidget.previewBtn.setEnabled(False)
    self.dockwidget.cosmetic_senddataBtn.setEnabled(False)
    self.dockwidget.cosmetic_loadataBtn.setEnabled(False)
    self.dockwidget.acceptJobBth.setEnabled(False)
    self.dockwidget.cosmeticCombo.setEnabled(False)


def when_login(self, email):
    self.dockwidget.username.setReadOnly(1)
    self.dockwidget.password.setReadOnly(1)
    self.dockwidget.password.setText("")
    self.dockwidget.username.setText("")
    self.dockwidget.checkNonpwa.setEnabled(0)
    self.dockwidget.logoutBtn.setEnabled(1)
    self.dockwidget.loginBtn.setEnabled(0)
    self.dockwidget.changeDepartmentBnt.setEnabled(1)
    self.dockwidget.tabWidget.setEnabled(1)

    # Edit TAB Button Disable
    self.dockwidget.add_Btn.setEnabled(0)
    self.dockwidget.edit_Btn.setEnabled(0)
    self.dockwidget.delete_Btn.setEnabled(0)
    self.dockwidget.edit_loadataBtn.setEnabled(0)

    # Report TAB Button Disable
    self.dockwidget.show_reportBtn.setEnabled(0)
    self.dockwidget.report_downloadBtn.setEnabled(0)

    # Set All TAB Enable
    self.dockwidget.tabWidget.setTabEnabled(0, True)
    self.dockwidget.tabWidget.setTabEnabled(1, True)
    self.dockwidget.tabWidget.setTabEnabled(2, True)
    self.dockwidget.tabWidget.setTabEnabled(3, True)
    self.dockwidget.tabWidget.setTabEnabled(4, True)
    self.dockwidget.tabWidget.setTabEnabled(5, True)

    # Set search Disable
    self.dockwidget.searchBtn_2.setEnabled(0)
    self.dockwidget.searchBtn_4.setEnabled(0)
    self.dockwidget.searchBtn_5.setEnabled(0)

    # Set report
    self.dockwidget.groupBox_2.setEnabled(0)
    self.dockwidget.groupBox_3.setEnabled(0)

    self.geo_col = 0

    # Add combo notification
    self.dockwidget.notiFilterCombo.clear()
    self.dockwidget.notiFilterCombo.addItem("ทั้งหมด")
    self.dockwidget.notiFilterCombo.addItem("อ่านแล้ว")
    self.dockwidget.notiFilterCombo.addItem("ยังไม่อ่าน")

    # Add combo year report
    self.dockwidget.report_year_select_2.clear()
    self.dockwidget.report_year_select.clear()
    addComboYear(self)
    self.dockwidget.groupBox_6.setVisible(False)

    # Cosmetic
    self.dockwidget.previewBtn.setEnabled(False)
    self.dockwidget.cosmetic_senddataBtn.setEnabled(False)
    self.dockwidget.cosmetic_loadataBtn.setEnabled(False)
    self.dockwidget.acceptJobBth.setEnabled(False)
    self.dockwidget.cosmeticCombo.setEnabled(False)


def when_choseBranch(self):
    # Set
    self.dockwidget.changeDepartmentBnt.setEnabled(1)
    self.dockwidget.tabWidget.setEnabled(1)
    self.dockwidget.tabWidget.setCurrentIndex(0)

    # Set Btn TAB Report
    self.dockwidget.show_reportBtn.setEnabled(1)

    self.dockwidget.report_downloadBtn.setEnabled(1)

    self.dockwidget.edit_loadataBtn.setEnabled(1)

    # Set search Enable
    self.dockwidget.searchBtn_2.setEnabled(1)
    self.dockwidget.searchBtn_4.setEnabled(1)
    self.dockwidget.searchBtn_5.setEnabled(1)

    # Set home button Enable
    self.dockwidget.homeBtn.setEnabled(1)

    # Set pipe project Enable
    self.new_project.setEnabled(True)

    # Cosmetic
    self.dockwidget.previewBtn.setEnabled(True)
    self.dockwidget.tabWidget.setCurrentIndex(0)
    self.dockwidget.notiStack.setCurrentIndex(0)


def when_search(self):
    self.dockwidget.tabWidget.setEnabled(0)


def when_search_finish(self):
    self.dockwidget.tabWidget.setEnabled(1)


def make_dir(self):
    district = self.dlg1.districtCombo.currentText()
    directory = district.split(' ')
    data_path = os.path.join(self.plugin_dir, "Data", directory[1])
    if not os.path.exists(data_path):
        os.makedirs(data_path)
        return directory[1]
    else:
        return directory[1]


def reference_id(self):
    try:
        a_ref = str(ULID())
    except:
        a_ref = str(ULID())
    return


def data_dic(self):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            # Data Dic for building useType
            url = self.baseUrl + "/api/2.0/resources/references/building-use-types?limit=1000"

            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }

            response = requests.request("GET", url, headers=headers, data=payload)
            json_file = "building_useType.json"
            json_path = os.path.join(self.plugin_dir, "json", json_file)
            if response.status_code == 200:
                numberReturn = response.json()["numberReturn"]
                dump_json = ""
                if numberReturn > 0:
                    self.building_useType = response.json()["items"]
                    dump_json = response.json()

                json_object = json.dumps(dump_json, indent=4)  # dump jsonfile
                with open(json_path, 'w', encoding='utf-8') as file:  # open file in write-mode
                    file.write(json_object)

            with open(json_path, 'r', encoding='utf-8') as file:  # open file in read-mode
                data = json.load(file)
                self.building_useType = data['items']

            # Data Dic for meter size
            url = self.baseUrl + "/api/2.0/resources/references/meters-sizes?limit=1000"

            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }

            response = requests.request("GET", url, headers=headers, data=payload)
            if response.status_code == 200:
                numberReturn = response.json()["numberReturn"]
                if numberReturn > 0:
                    self.meter_size = response.json()["items"]
                    dump_json = response.json()

                    json_file = "meter_size.json"
                    json_path = os.path.join(self.plugin_dir, "json", json_file)
                    json_object = json.dumps(dump_json, indent=4)  # dump jsonfile
                    with open(json_path, 'w', encoding='utf-8') as file:  # open file in write-mode
                        file.write(json_object)

            with open(json_path, 'r', encoding='utf-8') as file:  # open file in read-mode
                data = json.load(file)
                self.meter_size = data['items']

            # Data Dic for meter brand
            url = self.baseUrl + "/api/2.0/resources/references/meter-brands?limit=1000"
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }

            response = requests.request("GET", url, headers=headers, data=payload)
            if response.status_code == 200:
                numberReturn = response.json()["numberReturn"]
                if numberReturn > 0:
                    self.meter_brand = response.json()["items"]
                    agi = response.json()

                    json_file = "meter_brand.json"
                    json_path = os.path.join(self.plugin_dir, "json", json_file)
                    json_object = json.dumps(agi, indent=4)  # dump jsonfile
                    with open(json_path, 'w', encoding='utf-8') as file:  # open file in write-mode
                        file.write(json_object)

            with open(json_path, 'r', encoding='utf-8') as file:  # open file in read-mode
                data = json.load(file)
                self.meter_brand = data['items']

            # Data Dic for all reference
            url = self.baseUrl + "/api/2.0/resources/references"
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }

            response = requests.request("GET", url, headers=headers, data=payload)
            json_file = "referances.json"
            json_path = os.path.join(self.plugin_dir, "json", json_file)
            if response.status_code == 200:
                reference = response.json()["referances"]
                agi = response.json()
                # Export to JSON
                json_referances = json.dumps(agi, indent=4)  # dump jsonfile
                with open(json_path, 'w', encoding='utf-8') as file:  # open file in write-mode
                    file.write(json_referances)

            with open(json_path, 'r', encoding='utf-8') as file:  # open file in read-mode
                data = json.load(file)
                reference = data['referances']

            # building
            self.buildingTypes = reference["building"]["buildingTypes"]
            self.useStatus = reference["building"]["useStatus"]
            # firehydrant
            self.firehydrantSizes = reference["firehydrant"]["firehydrantSizes"]
            self.firehydrantStatus = reference["firehydrant"]["firehydrantStatus"]
            # pipe
            self.pipeClasses = reference["pipe"]["pipeClasses"]
            self.pipeFunctions = reference["pipe"]["pipeFunctions"]
            self.pipeGrades = reference["pipe"]["pipeGrades"]
            self.pipeLayings = reference["pipe"]["pipeLayings"]
            self.pipeProducts = reference["pipe"]["pipeProducts"]
            self.pipeTypes = reference["pipe"]["pipeTypes"]
            self.pipeSizes = reference["pipe"]["pipeSizes"]
            # valve
            self.valveStatus = reference["valve"]["valveStatus"]
            self.valveTypes = reference["valve"]["valveTypes"]
            self.valveSizes = reference["valve"]["valveSizes"]
            self.valveFunctions = reference["valve"]["valveFunctions"]
            # pwawaterwork
            self.costcenters = reference["pwawaterwork"]["costcenters"]
            self.pwaStations = reference["pwawaterwork"]["pwaStations"]
            # road
            self.roadFunctions = reference["road"]["roadFunctions"]
            self.roadTypes = reference["road"]["roadTypes"]
            # struct
            self.structTypes = reference["struct"]["structTypes"]
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)

    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def load_cusAddress(self, customer_id):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/customer-address-informations?customerId=" + str(
                customer_id)

            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            if response.status_code == 200:
                cusTomerAddress = response.json()["items"]

                return cusTomerAddress[0]
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def load_customer_new(self, custCode):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/customer-informations?custCode=" + str(custCode)
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            if response.status_code == 200:
                items = response.json()["items"]
                customer_id = items[0]['id']
                installCusTitle = items[0]['installCusTitle']
                if installCusTitle == 'NULL':
                    installCusTitle = ""
                installCusName = items[0]['installCusName']
                installCusSurname = items[0]['installCusSurname']
                meterRouteId = items[0]['meterRouteId']
                meterRouteSeq = items[0]['meterRouteSeq']
                contracNo = items[0]['contracNo']
                cusType = items[0]['cusTypeId']
                # cusType = items[0]['cusType']
                custFullName = str(installCusTitle) + str(installCusName) + " " + str(installCusSurname)
                customerInfo = items[0]
                # return customerInfo # Correct 27-11-2567
                # return custFullName, customer_id, meterRouteId, meterRouteSeq, contracNo, cusType

            else:
                customerInfo = []
                # "Not found"
            return customerInfo  # Correct 27-11-2567
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def load_customer(self, custCode):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/customer-informations?custCode=" + str(custCode)
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            if response.status_code == 200:
                items = response.json()["items"]
                customer_id = items[0]['id']
                installCusTitle = items[0]['installCusTitle']
                if installCusTitle == 'NULL':
                    installCusTitle = ""
                installCusName = items[0]['installCusName']
                installCusSurname = items[0]['installCusSurname']
                meterRouteId = items[0]['meterRouteId']
                meterRouteSeq = items[0]['meterRouteSeq']
                contracNo = items[0]['contracNo']
                cusType = items[0]['cusTypeId']
                # cusType = items[0]['cusType']
                custFullName = str(installCusTitle) + str(installCusName) + " " + str(installCusSurname)

                return custFullName, customer_id, meterRouteId, meterRouteSeq, contracNo, cusType
            else:
                "Not found"
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def load_meter(self,  meterNo):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/meters?meterNo=" + str(meterNo)

            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            if response.status_code == 200:
                numberReturn = response.json()["numberReturn"]
                if numberReturn > 0:
                    items = response.json()["items"]
                    return items[0]
                else:
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Warning)
                    msg.setText("ไม่พบ")
                    msg.setWindowTitle("PWA Message")
                    msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                    retval = msg.exec_()
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def make_data_dir(self, data_dir):
    data_path = os.path.join(self.plugin_dir, data_dir)
    if not os.path.exists(data_path):
        os.makedirs(data_path)
        return "create"
    else:
        return "exists"


def load_district(self):
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/references/pwa-districts"

            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
        else:
            message = "Can not get token from server"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)


def check_module(self):
    modules = ['os', 'requests', 're', 'configparser', 'pandas', 'urlopen', 'datetime', 'pytz', 'geopandas', 'geojson', 'sqlite3', 'ulid', 'loads', 'time', 'codecs']
    for module in modules:
        if module in sys.modules:
            print('module: ' + module + ' already installed')
        else:
            print('install module: ' + module)
            install(module)


def load_new_token(self):
    if checkNetConnection() is True:
        url = self.baseUrl + "/api/2.0/token"
        payload = 'grant_type=refresh_token&refresh_token=' + self.refreshToken_new
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        response = requests.request("POST", url, headers=headers, data=payload)

        if response.status_code == 200:
            response = response.json()
            token = response['accessToken']
            refreshToken = response['refreshToken']
            self.token_new = token
            self.refreshToken_new = refreshToken
            self.config.set('settings', 'refreshtoken_new', str(self.refreshToken_new))
            with open(self.configpath, 'w') as configfile:
                self.config.write(configfile)
            self.refreshToken_new = self.config.get('settings', 'refreshtoken_new')
            update_token_new(self)
            t_status = "0"
        else:
            t_status = "1"
        return t_status
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return "err"


def check_token_expired(self):
    if checkNetConnection() is True:
        url = self.baseUrl + "/api/2.0/resources/references/pipe-types"

        payload = {}
        headers = {
            'Authorization': 'Bearer ' + self.token_new
        }
        response = requests.request("GET", url, headers=headers, data=payload)
        t_status = ""
        if response.status_code == 200:
            numberReturn = response.json()["numberReturn"]
            if numberReturn > 0:
                t_status = "0"
                print("Token not expire")
        else:
            t_status = "1"
        return t_status
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return "err"


def check_oldToken_expired(self):
    if checkNetConnection() is True:
        o_status = ""
        url = self.host + "/features/1.1/collections?itemType=Feature&search=B5521011_L"
        payload = {}
        headers = {
            'Authorization': 'Bearer ' + self.token
        }
        response = requests.request("GET", url, headers=headers, data=payload)
        if response.status_code == 200:
            numberMatched = response.json()["numberMatched"]
            if numberMatched > 0:
                o_status = "0"
                print("Token_not_exp")
        else:
            o_status = "1"
            print("Token_exp")
        return o_status
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return "err"


def getCollectionID_new(self, dataLayer):
    searchtxt = "B" + self.currentbranch + "_" + dataLayer
    self.dockwidget.LogTextEdit.insertPlainText(searchtxt)
    collectionID = ""
    if checkNetConnection() is True:
        t_status = check_token_expired(self)
        if t_status == "1":
            t_status = load_new_token(self)
        if t_status == "0":
            url = self.baseUrl + "/api/2.0/resources/features/pwa/collections?title=" + searchtxt
            print(url)
            payload = {}
            headers = {
                'Authorization': 'Bearer ' + self.token_new
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            if response.status_code == 200:
                numberMatched = response.json()["numberMatched"]
                if numberMatched > 0:
                    collections = response.json()["collections"]
                    collectionID = collections[0]["id"]
                print("Found")
                return collectionID
            else:
                print("Not found")
                return collectionID
        else:
            print("err")
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return collectionID


def append_pipeType(self):
    pipeType = self.pipeTypes
    pipeTypeId = []
    pipeTypeDes = []
    for i in range(len(pipeType)):
        pipeTypeId.append(pipeType[i]['typeId'])
        pipeTypeDes.append(pipeType[i]['description'])
    return pipeTypeId, pipeTypeDes


def append_pipeSize(self):
    pipeSize = self.pipeSizes
    pipeSizeId = []
    pipeSizeDes = []
    pipeSizeType = []
    for i in range(len(pipeSize)):
        pipeSizeId.append(pipeSize[i]['sizeId'])
        pipeSizeDes.append(pipeSize[i]['description'])
        pipeSizeType.append(pipeSize[i]['type'])
    return pipeSizeId, pipeSizeDes, pipeSizeType


def find_pipeId(pipeType_Id, pipeType_Des, search_Des):
    for i in range(len(pipeType_Id)):
        if pipeType_Des[i] == search_Des:
            return pipeType_Id[i]


def find_pipeSizeDes(self, pipeSizeId, pipeSizeDes, pipeSizeType, search_text):
    list_piepSizeDes = []
    for i in range(len(pipeSizeId)):
        if pipeSizeType[i] == search_text:
            list_piepSizeDes.append(pipeSizeDes[i])
    return list_piepSizeDes


def startup(self):
    svgPathList = QgsApplication.svgPaths()
    myApp_svgPath = os.path.join(self.plugin_dir, "ui_form")
    for svgPath in svgPathList:
        if svgPath == myApp_svgPath:
            print("svgPath in list")
        else:
            QgsApplication.setDefaultSvgPaths([myApp_svgPath])


def addComboYear(self):
    import datetime
    current_year = datetime.datetime.now().year
    start_year = 1979 
    
    # Generate year list in descending order for optimal user experience
    year_list = []

    # Iterate from current year backwards to historical baseline
    for year in range(current_year, start_year - 1, -1):
        # Convert to Buddhist Era if required by organizational standards
        buddhist_year = year + 543
        year_list.append(str(buddhist_year))
    
    # Clear existing combo box entries to prevent data inconsistency
   
    self.dockwidget.report_year_select_2.clear()
    self.dockwidget.report_year_select_3.clear()
    self.dockwidget.report_year_select.clear()

    self.dockwidget.report_year_select_2.addItem("โปรดเลือกปี")
    self.dockwidget.report_year_select_3.addItem("โปรดเลือกปี")
    self.dockwidget.report_year_select.addItem("โปรดเลือกปี")

    # Populate combo box with descending year sequence
    for year_entry in year_list:
        self.dockwidget.report_year_select_2.addItem(year_entry)
        self.dockwidget.report_year_select_3.addItem(year_entry)
        self.dockwidget.report_year_select.addItem(year_entry)

    self.dockwidget.report_year_select.setCurrentIndex(1)
    self.dockwidget.report_year_select_2.setCurrentIndex(1)
    self.dockwidget.report_year_select_3.setCurrentIndex(1)

def getMetaData(self):
    metaText = configparser.ConfigParser()
    metaPath = os.path.join(self.plugin_dir, 'metadata.txt')
    metaText.read(metaPath)
    pluginVersion = metaText.get('general', 'version')
    return pluginVersion


def retrievePluginVersion(self):
    data = ""
    if checkNetConnection() is True:
        url = "https://gisapp.pwa.co.th/api/1.0/desktop-versions/latest"
        payload = {}
        headers = {}
        response = requests.request("GET", url, headers=headers, data=payload)
        if response.status_code == 200:
            data = response.json()
        else:
            pass
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return "err"

    return data


def checkPluginVersion(self, clientVersion):
    supportVer = True
    clientVersion = str(clientVersion)
    #if len(clientVersion) > 1:
    #    clientVersion = str(clientVersion) + "*"
    if checkNetConnection() is True:
        url = "https://gisapp.pwa.co.th/api/1.0/desktop-versions?version=" + str(clientVersion)
        payload = {}
        headers = {}
        response = requests.request("GET", url, headers=headers, data=payload)
        if response.status_code == 200:
            data = response.json()
            numberMatch = data['numberMatch']
            if numberMatch > 0:
                supportVer = data['items'][0]['supported']
            else:
                supportVer = False
        else:
            pass
    else:
        message = "No internet connection."
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        return "err"

    return supportVer


def alertMsgBox(printMessage):
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Warning)
    msg.setText(str(printMessage))
    msg.setWindowTitle("PWA Message")
    msg.setStandardButtons(QMessageBox.Ok)
    retval = msg.exec_()


def infoMsgBox(printMessage):
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Information)
    msg.setText(str(printMessage))
    msg.setWindowTitle("PWA Message")
    msg.setStandardButtons(QMessageBox.Ok)
    retval = msg.exec_()

