# -*- coding: utf-8 -*-
"""
/***************************************************************************
 pwagis
                                 A QGIS plugin
 PWA
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-15
        git sha              : $Format:%H$
        copyright            : (C) 2024 by PWA
        email                : pwa
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
import os
# Check library
# from pwagis.check_module import *

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QObject, QFileInfo, pyqtSignal, \
    pyqtSlot, QTimer, QFile, QDataStream, QIODevice
from qgis.PyQt.QtXml import QDomDocument
# from PyQt5.QtXml import QDomDocument
from qgis.PyQt.QtGui import QIcon, QPixmap
from qgis.PyQt.QtWidgets import QAction, QAbstractItemView, QFileDialog, QDialog, QAction, QMessageBox, QTreeWidgetItem
from qgis.core import QgsVectorLayer, QgsProject, QgsPoint, QgsRectangle, QgsCoordinateReferenceSystem, \
    QgsRasterLayer, QgsEditorWidgetSetup, QgsEditFormConfig, QgsPageSizeRegistry, QgsLayoutItemPage, \
    QgsCoordinateTransform, QgsPrintLayout, QgsLayoutItemMap, QgsLayoutItemMapGrid, QgsLayoutItemLabel, \
    QgsLayoutPoint, QgsUnitTypes, QgsLayoutSize, QgsLayoutExporter, QgsLayoutItemPage, QgsRectangle, QgsPoint, \
    QgsReadWriteContext, QgsMapLayer, QgsApplication, QgsSettings

from qgis.utils import *

from qgis.gui import QgsVertexMarker, QgsAttributeForm, QgsMapToolIdentify, QgsMapTool, QgsMapToolIdentifyFeature, \
    QgsMapToolExtent, QgsMapToolEmitPoint


# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .pwagis_dockwidget import pwagisDockWidget, changeDepartmentDialog, confirmEditDialog, importImageDialog, reportDialog, fireDialog, \
    dmaDialog, pwaWaterworksDialog, valveDialog, pipeDialog, bldgDialog, meterDialog, leakDialog, notificationDialog, \
    structDialog, pipeServeDialog, flowMeterDialog, stepTestDialog, projectDialog

from .layout_dialog import layoutDialog

import json
import requests
import subprocess
import re
import webbrowser

import shutil
import configparser

from pwagis.utiles import *
from pwagis.datalayer import *
from pwagis.search import *
from pwagis.edit import *
from pwagis.report import *
from pwagis.creatform import *
from pwagis.integrate_ui import *
from pwagis.notification import *
from pwagis.cosmetic import *
from pwagis.pipe_project import *

from .gpstime import gpstime

import pandas as pd

# Import for custom tools
from qgis.core import Qgis as QGis
from pwagis.utils.utils import DelToolBarIface, obtainAction

# Set macro mode to always execute
# QgsSettings().setEnumValue("qgis/enableMacros", Qgis.PythonMacroMode.Always)
QSettings().setValue('qgis/enableMacros', 'Always')

# Set Auto open Form
QSettings().setValue('/Map/identifyAutoFeatureForm', True)

try:
    from pydevd import *
except ImportError:
    None

class pwagis:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface
        self.timer = QTimer()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        global plugin_dir
        plugin_dir = self.plugin_dir

        # Custom Tools
        """
        self.userhome = os.path.expanduser('~')        
        self.filepath = self.userhome + '//.CustomToolBars'
        self.file = QFile(self.filepath)
        """
        self.filepath = self.plugin_dir + '//mytoolsBar//0.CustomToolBars'
        self.file = QFile(self.filepath)

        # initialize locale

        # locale = QSettings().value('locale/userLocale')[0:2]

        """
        plugin_dir = os.path.dirname(__file__)
        locale = QgsApplication.instance().locale()
        locale_path = os.path.join(
            plugin_dir, 'i18n', f'identifyplus_{locale}.qm'
        )
        """
        locale = QgsApplication.instance().locale()
        locale_path = os.path.join(
            plugin_dir, 'i18n', f'pwagis_{locale}.qm'
        )
        """
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'pwagis_{}.qm'.format(locale))
        """
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&pwagis')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'pwagis')
        self.toolbar.setObjectName(u'pwagis')

        #print "** INITIALIZING pwagis"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('pwagis', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/pwagis/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'PWAGIS'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # create the toolbar icon and menu print Layout
        icon_path = ':/plugins/pwagis/icon_2.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Layout'),
            callback=self.runLayout,
            parent=self.iface.mainWindow())

        # create the toolbar icon and menu Search
        icon_path = ':/plugins/pwagis/Search.png'
        self.goToSearch = self.add_action(
            icon_path,
            text=self.tr(u'Search'),
            callback=self.go_to_search,
            parent=self.iface.mainWindow())
        self.goToSearch.setCheckable(False)

        # create the toolbar icon and menu Edit
        icon_path = ':/plugins/pwagis/Edit.png'
        self.goToEdit = self.add_action(
            icon_path,
            text=self.tr(u'Edit'),
            callback=self.go_to_edit,
            parent=self.iface.mainWindow())
        self.goToEdit.setCheckable(False)

        # create the toolbar icon and menu entry Map Tools
        icon_path = ':/plugins/pwagis/info.png'
        self.map_tool_action = self.add_action(
            icon_path,
            text=self.tr(u'Map Tool'),
            callback=self.map_tool_init,
            parent=self.iface.mainWindow())
        self.map_tool_action.setCheckable(True)
        """
        # create the toolbar icon and menu entry Map Tools Meter
        icon_path = ':/plugins/pwagis/icon-layer.png'
        self.meter_tool_action = self.add_action(
            icon_path,
            text=self.tr(u'Meter Tool'),
            callback=self.meter_tool_init,
            parent=self.iface.mainWindow())
        self.meter_tool_action.setCheckable(True)
        """
        # create the toolbar icon and menu entry New Project
        icon_path = ':/plugins/pwagis/Newproject-icon.png'
        self.new_project = self.add_action(
            icon_path,
            text=self.tr(u'New Prpject'),
            callback=self.createNewProject,
            parent=self.iface.mainWindow())
        self.new_project.setEnabled(False)

        # Setup the timer to call the run_function method every 2 minutes
        # self.timer.timeout.connect(self.load_message)
        # self.timer.start(120000)  # 120000 milliseconds = 2 minutes
        # MyToolBars
        self.MyToolBars()

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # print "** CLOSING pwagis"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        # print "** UNLOAD pwagis"
        # Stop the timer when the plugin is unloaded
        self.timer.stop()

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&pwagis'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def run_function(self):
        message = ""
        self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)

    def deleteData_pop(self):        
        self.dlg3.close()
        self.dlg3.show()

    def deletepop_close(self):
        self.dlg3.close() 

    def changeDepart_pop(self):
        self.dlg1.close()
        self.dockwidget.changeDepartmentBnt.setEnabled(0)
        self.dockwidget.tabWidget.setEnabled(0)
        self.get_district_list()
        # setting current index 
        self.dlg1.branchCombo.setCurrentIndex(0)
        self.dlg1.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.dlg1.show()
    
    def changeDepartpop_close(self):
        self.dockwidget.changeDepartmentBnt.setEnabled(1)
        self.dockwidget.tabWidget.setEnabled(1)
        self.dlg1.close()     

    def importImage_pop(self):
        self.dlg2.close()
        self.dlg2.show()

    def importImagepop_close(self):
        self.dlg2.close()

    def logins(self):
        self.iface.mainWindow().statusBar().showMessage("")
        self.dockwidget.loginBtn.setEnabled(False)
        message = "Loging in, please wait."
        self.iface.messageBar().pushMessage("Information", message, level=0, duration=3)
        if checkNetConnection() is True:
            user_new = self.dockwidget.username.text().strip()  # data%40pwa.co.th
            password_new = self.dockwidget.password.text().strip()  # Nr5NgzD6oKAcaD
            token_new, refreshtoken_new, group = login_new(self, user_new, password_new)
            if not token_new == "error":
                self.userGroup = group
                self.token_new = token_new
                when_login(self, user_new)
                message = "Login Success."
                self.iface.messageBar().pushMessage("infomation  ", message, level=0, duration=3)
                self.loadMap()
                data_dic(self)
                
                # Create Data Folder
                mk_data_dir = make_data_dir(self, data_dir="Data")
                # Create Style Folder
                mk_style_dir = make_data_dir(self, data_dir="style")

                retrieveAllNotification(self)
                # Setup the timer to call the run_function method every 2 minutes
                self.timer.timeout.connect(self.load_message)
                self.timer.start(1200000)  # 1200000 milliseconds = 20 minutes

                addDataLayerCombo(self)  # Add Combo layer to search
                addReportType(self)
                setTileIcon(self)
        else:
            self.dockwidget.loginBtn.setEnabled(True)
            message = "No internet connection."
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)

    def logout(self):
        result = logout(self, self.host)
        if result == 204:
            when_logout(self)
            self.reset_search()
            clear_layer_combo(self)
            # find_amount_layer(self)
            groupName = "B" + str(self.currentbranch) + "_Baselayer"
            find_amount_layer(self, groupName)
            self.timer.stop()
            message = "Logout Success."
            self.iface.messageBar().pushMessage("infomation  ", message, level=0, duration=3)

    # Function get distict name to
    def get_district_list(self):
        if checkNetConnection() is True:
            pwaCode = retrieveGroup(self)
            res = []
            res[:] = pwaCode
            userType = checkUserGroup(self, res)
            self.userType = userType
            if userType == "District":
                currentDistrict = pwaCode
                dataBranch = listAllBranch(self, currentDistrict, userType)
                allDistrict = listAllDistrict(self)
                districtCode = pwaCode
                pwaDistrictName = show_District(self, allDistrict, districtCode)
                branchList, pwaBranchCode, districtCode = ShowAllBranch(self, dataBranch)
                self.districtCode = pwaCode
            elif userType == "Branch":
                currentBranch = pwaCode
                data = getBranch(self, currentBranch)
                districtCode = data["branches"][0]["districtCode"]
                self.districtCode = districtCode
                branchCode = data["branches"][0]["pwaCode"]
                # print("cur : " + str(currentBranch))
                # print("ooo : " + str(branchCode))
                # print("123 : " + str(districtCode))
                allDistrict = listAllDistrict(self)
                pwaDistrictName = show_District(self, allDistrict, districtCode)
                pwaBranchName = show_Branch(self, data, currentBranch)

            elif userType == "Center":
                data = listAllDistrict(self)
                districtList, firstPwaDistrictCode = list_district(self, data)
                currentDistrict = self.dlg1.districtCombo.currentIndex() + 1
                dataBranch = listAllBranch(self, currentDistrict, userType)
                branchList, pwaBranchCode, districtCode = ShowAllBranch(self, dataBranch)
                #self.tem_branchCode = branchCode
                self.pwaBranchCode = pwaBranchCode
                self.districtCode = districtCode
            # pwaCode = list_district(self)
            # district_list = list_district(self)
            # self.dockwidget.LogTextEdit.setPlainText(str(district_list))
        else:
            message = "No internet connection."
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3) 

    def get_branch_list(self):
        userType = self.userType
        currentDistrict = ""
        if userType == "Center":
            currentDistrict = self.dlg1.districtCombo.currentIndex() + 1
        elif userType == "District":
            currentDistrict = self.currentdistrict
        elif userType == "Branch":
            currentDistrict = self.currentdistrict

        if checkNetConnection() is True:
            # branch_list = list_branch(self)
            # self.dockwidget.LogTextEdit.setPlainText(str(branch_list))
            dataBranch = listAllBranch(self, currentDistrict, userType)
            branchList, pwaBranchCode, districtCode = ShowAllBranch(self, dataBranch)
            #self.tem_branchCode = branchCode
            self.pwaBranchCode = pwaBranchCode
            self.districtCode = districtCode
        else:
            message = "No internet connection."
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3) 

    def choseDepartment(self):

        self.dlg1.close()
        message = "กำลังเตรียมข้อมูลสาขา"
        self.dockwidget.db_label.setText("")
        self.iface.messageBar().pushMessage("Information  ", message, level=0, duration=3)
        # Reset search
        self.reset_search()
        # Reset Combo layer
        clear_layer_combo(self)
        # Remove all layer on map when change branch
        # removeAllLayer(self)
        # find_amount_layer(self)
        groupName = "B" + str(self.currentbranch) + "_Baselayer"
        find_amount_layer(self, groupName)
        # groupName = "B" + str(self.currentbranch) + "_EditLayer"
        groupName = "Edit Layers"
        find_amount_layer(self, groupName)

        """
        if self.userType != "Branch":
            pwa_office = self.currentBranchs
        else:
            pwa_office = get_district_branch_code(self)
        """
        pwa_office = get_district_branch_code(self)
        # Update Current District
        update_current_district(self, pwa_office)
        # Update Current Branch
        update_current_branch(self, pwa_office)
        # Get Collection data (id and title)
        tile_name, tile_title, tile_bounds, style_list, display_name = get_Tile_by_Branch(self)
        # tile_collectionId, tile_title = get_collectionID_by_Branch(self)
        canvas = self.iface.mapCanvas()
        load_world_map(self)
        load_world_map4(self)
        load_world_map2(self)
        load_world_map3(self)
        groupName = "B" + str(self.currentbranch) + "_Baselayer"
        group, root = createGroup(self, groupName)
        # Load Tile layer to map

        if len(tile_name) > 0:

            load_Tile(self, tile_name, tile_title, style_list, display_name, group, root)
            bounds = tile_bounds[0]
            """
            for i in range(len(tile_bounds)):
                testBounds = tile_bounds[i]
                if testBounds is not None:
                    bounds = testBounds
                    i = len(tile_bounds)
            """
            # bounds = load_Tile(self, tile_collectionId, tile_title)
            if len(bounds) > 0:
                self.home_bounds = bounds
                rect = zoomto_layer(self, bounds)
                canvas.setExtent(rect) 
                canvas.refresh()
                # Get Current bbox
                extent = self.iface.mapCanvas().extent()
            clone = group.clone()
            root.insertChildNode(0, clone)
            parent = group.parent()
            parent.removeChildNode(group)
        else:
           message = "TILE Data Not Found"
           self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
           bounds = [-180, -90, 180, 90]
           self.home_bounds = bounds
           rect = zoomto_layer(self, bounds)
           canvas.setExtent(rect)
           canvas.refresh()
           extent = self.iface.mapCanvas().extent()
        result = getCollection_New(self, "*")
        if result == "success":
            self.dockwidget.edit_datalayer_combo.clear()
            data = json.loads(self.collection_json)
            for i in range(len(data['collection'][0]['items'])):
                datalayer = data['collection'][0]['items'][i]['itemtype']
                # if datalayer == "STRUCT" or datalayer == "FLOW_METER" or datalayer == "PIPE_SERV" or datalayer == "STEP_TEST":
                if datalayer == "STRUCT" or datalayer == "PIPE_SERV":
                    pass
                else:
                    self.dockwidget.edit_datalayer_combo.addItem(data['collection'][0]['items'][i]['itemtype'])
                    # print(str(data['collection'][0]['items'][i]['itemtype']))

            # Get bounds form pipe old version
            # bounds = get_bound(self)  # remark if use new ver
            self.home_bounds = bounds
            rect = zoomto_layer(self, bounds)
            canvas.setExtent(rect)
            # Get bounds form pipe old version
            canvas.refresh()  # remark if use new ver
        # Show Current branch

        """ Set Branch Text"""
        self.branch_text = self.dlg1.branchCombo.currentText()
        self.dockwidget.branch_label.setText("สาขาที่ใช้งาน : " + self.branch_text)

        when_choseBranch(self)

        # Close Dialog
        if self.userType != "Branch":
            self.dlg1.close()

    def searchData(self):
        self.dockwidget.searchBtn_2.setEnabled(0)
        self.dockwidget.searchBtn_3.setEnabled(0)
        self.dockwidget.searchBtn_4.setEnabled(0)
        self.dockwidget.searchBtn_5.setEnabled(0)

        self.dockwidget.restBtn_2.setEnabled(0)
        self.dockwidget.restBtn_3.setEnabled(0)
        self.dockwidget.restBtn_4.setEnabled(0)
        self.dockwidget.restBtn_5.setEnabled(0)

        message = ("กำลังค้นหาข้อมูล")
        self.iface.messageBar().pushMessage("Information  ", message, level=0, duration=4)

        self.dockwidget.resultTable.setRowCount(0)
        self.dockwidget.resultTable.setEnabled(1)
        self.dockwidget.resultTable.horizontalHeader().setVisible(False)
        self.dockwidget.resultTable.clear()
        when_search(self)

        search_text = self.dockwidget.datalayercombo.currentText()  
        attribute, search_para = search_data(self, search_text)
        collectionsID = getCollectionID_new(self, search_para)
        print("ColldectionID : " + str(collectionsID))
        print("attibute : " + str(attribute))
        print("seach_para : " + str(search_para))
        # properties, geo_df = getItem_filter(self, collectionsID, attribute, search_para)
        properties, geo_df = getItem_filter_new(self, collectionsID, attribute, search_para)
        loadResultToTable(self, properties, geo_df)
        when_search_finish(self)
        # self.token = "0"   # crack token
        # self.dockwidget.resultTable.setEnabled(0)
        message = ("ค้นหาข้อมูลเรียบร้อยแล้ว")
        self.iface.messageBar().pushMessage("Information  ", message, level=0, duration=4)
        self.dockwidget.searchBtn_2.setEnabled(1)
        self.dockwidget.searchBtn_3.setEnabled(1)
        self.dockwidget.searchBtn_4.setEnabled(1)
        self.dockwidget.searchBtn_5.setEnabled(1)

        self.dockwidget.restBtn_2.setEnabled(1)
        self.dockwidget.restBtn_3.setEnabled(1)
        self.dockwidget.restBtn_4.setEnabled(1)
        self.dockwidget.restBtn_5.setEnabled(1)

    def get_data_row(self):
        row = self.dockwidget.resultTable.currentIndex().row()
        # column = self.dockwidget.resultTable.currentIndex().column()
        section_id = self.dockwidget.tempTable.item(row, 0).text()
        geo_text = self.dockwidget.tempTable.item(row, 1).text()
        print(geo_text)
        zoomToPoint(self, geo_text)
        layer = self.iface.activeLayer()
        # layer.selectByExpression("\"id\" = '{}'".format(section_id))
        if layer and layer.type() == QgsMapLayer.VectorLayer:
             layer.selectByExpression("id='{}'".format(section_id))
             message = "Your selection is ID : " + section_id
        else:
            message = "Your selection is ID : " + section_id
        self.iface.messageBar().pushMessage("Information  ", message, level=0, duration=3)

    def more_cell(self):
        row = self.dockwidget.resultTable.currentIndex().row()
        column = self.dockwidget.resultTable.currentIndex().column()        
        col_count = self.dockwidget.resultTable.columnCount()
        if (col_count-1) == column:

            message = "You click cell : (" + str(row) + ", " + str(column) + ")"
            self.iface.messageBar().pushMessage("Information  ", message, level=0, duration=3)

    def selectDataLayer(self):
        add_attributeCombo(self)
    
    def clearSearchText(self):
        manage_search(self)                
        
    def clearattributeCombo(self):
        self.dockwidget.attributeCombo.clear()
        self.dockwidget.mGroupBox_2.hide()
        self.dockwidget.mGroupBox_4.hide()
        self.dockwidget.mGroupBox_5.hide()
        self.dockwidget.mGroupBox_6.hide()

    def reset_search(self):
        self.dockwidget.datalayercombo.setCurrentIndex(0)

    def edit_DataLayer_change(self):
            data = json.loads(self.collection_json)
            search_id = self.dockwidget.edit_datalayer_combo.currentText()
            result = list(filter(lambda x: x["itemtype"] == search_id, data['collection'][0]['items']))
            if len(result) > 0:
                collectionid = result[0]['collectionid']
                self.dockwidget.collectionID_temp.setText(collectionid)
            else:
                self.dockwidget.collectionID_temp.setText('')

    def edit_loaddata(self):
        # Clear Table unsuccessful Add
        self.dockwidget.tableUnsuccessful.setRowCount(0)
        self.dockwidget.tableUnsuccessful.horizontalHeader().setVisible(False)
        self.dockwidget.tableUnsuccessful.clear()
        # Clear Table unsuccessful Edit
        self.dockwidget.tableUnsuccessful_edit.setRowCount(0)
        self.dockwidget.tableUnsuccessful_edit.horizontalHeader().setVisible(False)
        self.dockwidget.tableUnsuccessful_edit.clear()

        # groupName = "B" + str(self.currentbranch) + "_EditLayer"
        groupName = "Edit Layers"
        removeGroup(self, groupName)
        group, root = createGroup(self, groupName)
        googleLayer = QgsProject.instance().mapLayersByName("Google Map")
        self.iface.setActiveLayer(googleLayer[0])
        refresh_data(self, root, group)
        print("Before Clone Group " + str(group) + ", " + str(root))
        clone = group.clone()
        root.insertChildNode(0, clone)
        parent = group.parent()
        parent.removeChildNode(group)

        """ parent = group_layer.parent()
            parent.removeChildNode(group_layer)

            # Insert the group at the top of the layer tree
            layer_tree.insertChildNode(0, group_layer_clone)
        """

    def edit_load_db_file(self):
        file_name_only = ""
        filename = QFileDialog.getOpenFileName(None, "Open File", self.plugin_dir, "Database (*.gpkg)")[0]
        if filename:
            file_name_only = os.path.basename(filename)
        self.dockwidget.db_label.setText(file_name_only)

    def edit_send_db_file(self):
        layer = self.iface.activeLayer()
        self.geo_col = 0
        self.geo_col_edit = 0
        m_action = "save"
        if layer.isModified() is True:
            m_action = stop_edit(self)

        if m_action == "save":
            # Clear Table unsuccessful
            result_add = 0
            result_edit = 0
            result_delete = 0
            add_message = ""
            edit_message = ""
            self.dockwidget.tableUnsuccessful.setRowCount(0)
            add_record, edit_record, delete_record = sum_cud(self)
            if len(add_record) > 0:
                result_add, add_message = export_add(self)
            if len(edit_record) > 0:
                result_edit, edit_message = export_edit(self)
            if len(delete_record) > 0:
                result_delete = export_delete(self)
            if result_add > 0 or result_edit > 0:
                print_message(add_message + "\n" + edit_message)
                if result_add > 0:
                    self.dockwidget.radio_add.setChecked(True)
                    self.dockwidget.stackedWidget.setCurrentIndex(0)
                else:
                    if len(add_record) == 0:
                        self.dockwidget.radio_add.setChecked(False)
                    elif len(add_record) > 0:
                        self.dockwidget.radio_add.setChecked(True)
                    self.dockwidget.radio_edit.setChecked(True)
                    self.dockwidget.stackedWidget.setCurrentIndex(1)
                # self.dockwidget.unsuccess_group.setEnabled(1)
            else:
                self.dlg3.show()

    def edit_export_edit(self):
        result = export_edit(self)
        self.dockwidget.add_Btn.setEnabled(0)
        self.dockwidget.edit_Btn.setEnabled(0)
        self.dockwidget.delete_Btn.setEnabled(0)

    def edit_export_add(self):
        result = export_add(self)
        self.dockwidget.add_Btn.setEnabled(0)
        self.dockwidget.edit_Btn.setEnabled(0)
        self.dockwidget.delete_Btn.setEnabled(0)

    def edit_export_delete(self):
        result = export_delete(self)
        self.dockwidget.add_Btn.setEnabled(0)
        self.dockwidget.edit_Btn.setEnabled(0)
        self.dockwidget.delete_Btn.setEnabled(0)

    def create_wgs84_crs():
        """Create WGS84 CRS with error handling"""
        try:
            dest_crs = QgsCoordinateReferenceSystem.fromEpsgId(4326)
            if not dest_crs.isValid():
                # Fallback to authority string method
                dest_crs = QgsCoordinateReferenceSystem.fromOgcWmsCrs('EPSG:4326')
            return dest_crs
        except Exception as e:
            # Log error and return default CRS
            print(f"CRS creation failed: {e}")
            return QgsCoordinateReferenceSystem()

    def loadMap(self):
        # load google map street as default
        load_world_map2(self)
        layers = self.iface.activeLayer()            
        #dest_crs = QgsCoordinateReferenceSystem(4326)
        dest_crs = QgsCoordinateReferenceSystem.fromEpsgId(4326)
        if not dest_crs.isValid():
            message = "Invalid coordinate reference system (EPSG:4326)"
            self.iface.messageBar().pushMessage("Warning", message, level=2, duration=3)
            return
        layers.setCrs(dest_crs)

    def selectPipeType(self):
        pipeType = self.dockwidget.attributeCombo_3.currentText()
        show_pipeId, show_pipeDes = append_pipeType(self)
        result = find_pipeId(show_pipeId, show_pipeDes, pipeType)

        pipeSizeId, pipeSizeDes, pipeSizeType = append_pipeSize(self)

        search_Sie_des = find_pipeSizeDes(self, pipeSizeId, pipeSizeDes, pipeSizeType, result)
        select_pipeSize = self.dockwidget.attributeCombo_4
        select_pipeSize.clear()
        select_pipeSize.addItem("ทุกขนาด")
        for i in range(len(search_Sie_des)):
            select_pipeSize.addItem(search_Sie_des[i])

    """ Report """
    def download_report(self):
        createReport(self, "download")

    def show_report(self):
        createReport(self, "view")

    def reportChange(self):
        report_type = self.dockwidget.report_id_select.currentIndex()

        report_id = 0
        if report_type == 1:
            report_id = 2
        elif report_type == 2:
            report_id = 3
        elif report_type == 3:
            report_id = 4
        elif report_type == 4:
            report_id = 5
        elif report_type == 5:
            report_id = 6
        elif report_type == 6:
            report_id = 1
        elif report_type == 7:
            report_id = 8
        elif report_type == 8:
            report_id = 12
        elif report_type == 9:
            report_id = 11
        """
        j = self.dockwidget.report_year_select.count()
        self.dockwidget.report_year_select.setCurrentIndex(j - 1)
        j = self.dockwidget.report_year_select_2.count()
        self.dockwidget.report_year_select_2.setCurrentIndex(j - 1)
        j = self.dockwidget.report_year_select_3.count()
        self.dockwidget.report_year_select_3.setCurrentIndex(j - 1)
        """
        self.dockwidget.report_year_select.setCurrentIndex(0)
        self.dockwidget.report_year_select_2.setCurrentIndex(0)
        self.dockwidget.report_year_select_3.setCurrentIndex(0)

        self.dockwidget.report_month_select.setCurrentIndex(0)
        if report_id == 0:
            self.dockwidget.reportStack.setCurrentIndex(0)
            self.dockwidget.groupBox_2.setEnabled(1)
            self.dockwidget.groupBox_3.setEnabled(0)
            self.dockwidget.groupBox_5.setEnabled(0)
            self.dockwidget.groupBox_7.setEnabled(0)
        elif report_id == 1 or report_id == 5 or report_id == 12:
            self.dockwidget.reportStack.setCurrentIndex(1)
            self.dockwidget.groupBox_3.setVisible(1)
            self.dockwidget.groupBox_2.setEnabled(0)
            self.dockwidget.groupBox_3.setEnabled(1)
            self.dockwidget.groupBox_5.setEnabled(0)
            self.dockwidget.groupBox_7.setEnabled(0)
        elif report_id == 6:
            self.dockwidget.reportStack.setCurrentIndex(2)
            self.dockwidget.groupBox_2.setEnabled(0)
            self.dockwidget.groupBox_3.setEnabled(0)
            self.dockwidget.groupBox_5.setEnabled(1)
            self.dockwidget.groupBox_7.setEnabled(0)
        elif report_id == 2 or report_id == 11:
            self.dockwidget.reportStack.setCurrentIndex(3)
            self.dockwidget.groupBox_2.setEnabled(0)
            self.dockwidget.groupBox_3.setEnabled(0)
            self.dockwidget.groupBox_5.setEnabled(0)
            self.dockwidget.groupBox_7.setEnabled(1)
        else:
            self.dockwidget.reportStack.setCurrentIndex(1)
            self.dockwidget.groupBox_3.setVisible(0)
            self.dockwidget.groupBox_2.setEnabled(0)
            self.dockwidget.groupBox_3.setEnabled(0)
            self.dockwidget.groupBox_5.setEnabled(0)
            self.dockwidget.groupBox_7.setEnabled(0)

    def createMap(self):
        rect = self.iface.mapCanvas().extent()
        title = "map"
        t = gpstime()
        outPath = os.path.join(self.plugin_dir, "qgis_PrintLayout_Carte25k_%s.png" % t.st_iso_epoch())
        taillesPages = QgsPageSizeRegistry()
        taillePage = taillesPages.find("A4")[0]

        orientation = QgsLayoutItemPage.Portrait
        scale = float("36000")
        # scale = float(rect.scale())
        crs = QgsCoordinateReferenceSystem(4326)

        bboxOrPoint = rect

        self.exportLayout(crs, taillePage, orientation, scale, bboxOrPoint, title, outPath)

    def exportLayout(self, crs, pageSize, orientation, scale, bboxOrPoint, title, outPath):
        mapLayerList = []
        layoutName = "PrintLayout_PWA"
        project = QgsProject.instance()
        s = str(type(bboxOrPoint))

        if re.search('QgsRectangle', s):
            rect = bboxOrPoint
        else:
            delta = 1e-4
            rect = QgsRectangle(bboxOrPoint.x() - delta, bboxOrPoint.y() - delta, bboxOrPoint.x() + delta,
                                bboxOrPoint.y() + delta)
        tr = QgsCoordinateTransform(QgsProject.instance().crs(), crs, QgsProject.instance())
        rect = tr.transform(rect)

        """ Layout Manager """
        manager = project.layoutManager()
        layouts_list = manager.printLayouts()

        if len(layouts_list) == 0:
            layout = QgsPrintLayout(project)
            layout.setName(layoutName)
            manager.addLayout(layout)
        else:
            layout_exist = False
            for layout in layouts_list:
                if layout.name() == layoutName:
                    layout_exist = True
                    print('Cleaning layout')
                    layout.clear()
                    break
                if not layout_exist:
                    layout = QgsPrintLayout(project)
                    layout.setName(layoutName)
                    manager.addLayout(layout)

        layout.initializeDefaults()

        pc = layout.pageCollection()
        page = pc.pages()[0]
        page.setPageSize(pageSize.displayName, orientation)

        map = QgsLayoutItemMap(layout)
        marge = 15
        width = (page.pageSize().width() - 2 * marge) * scale
        height = (page.pageSize().height() - 5 * marge) * scale  # Set map Height
        # height = (page.pageSize().height() - 2 * marge) * scale
        xCenter = 0.5 * (rect.xMinimum() + rect.xMaximum())
        yCenter = 0.5 * (rect.yMinimum() + rect.yMaximum())

        xMin = xCenter - width / 1e3 / 2
        xMax = xCenter + width / 1e3 / 2
        yMin = yCenter - height / 1e3 / 2
        yMax = yCenter + height / 1e3 / 2

        rectPrint = QgsRectangle(xMin, yMin, xMax, yMax)

        map.attemptMove(QgsLayoutPoint(marge, marge, QgsUnitTypes.LayoutMillimeters))
        map.attemptResize(QgsLayoutSize(width / scale, height / scale, QgsUnitTypes.LayoutMillimeters))
        map.setLayers(mapLayerList)
        map.setFrameEnabled(True)
        map.setCrs(crs)
        map.setExtent(rectPrint)
        map.updateBoundingRect()
        layout.addLayoutItem(map)
        map.setScale(scale)
        map. attemptMoveBy(2, page.pageSize().height() - 18 * marge)

        # grille
        grid = QgsLayoutItemMapGrid("grid", map)
        grid.setCrs(crs)

        dxy = 1000
        grid.setIntervalX(dxy)
        grid.setIntervalY(dxy)
        grid.setStyle(QgsLayoutItemMapGrid.Cross)
        grid.setFrameStyle(QgsLayoutItemMapGrid.InteriorTicks)
        grid.setAnnotationEnabled(True)
        grid.setAnnotationDirection(QgsLayoutItemMapGrid.Vertical, QgsLayoutItemMapGrid.Left)
        grid.setAnnotationDirection(QgsLayoutItemMapGrid.VerticalDescending, QgsLayoutItemMapGrid.Right)
        #        grid.setAnnotationFormat(QgsLayoutItemMapGrid.Decimal)
        grid.setAnnotationFormat(QgsLayoutItemMapGrid.CustomFormat)
        grid.setAnnotationExpression('@grid_number / 1000')
        grid.setAnnotationPrecision(0)
        map.grids().addItem(grid)

        name_01 = self.layoutDoc.name_01.text()

        label = QgsLayoutItemLabel(layout)
        label.setText("แผนผังการติดตั้งและวางท่อประปา " + str(name_01))
        label.setFont(QFont('BrowalliaUPC', 22))  # Change to your desired font and size
        label.setHAlign(Qt.AlignCenter)
        label.adjustSizeToText()
        # set a fixed width for the label
        label.attemptResize(QgsLayoutSize(page.pageSize().width(), label.boundingRect().height()))
        # label.attemptMoveBy(marge, page.pageSize().height() - 19 * marge)
        layout.addItem(label)

        label = QgsLayoutItemLabel(layout)
        label.setText(crs.authid() + ' - ' + crs.description())
        label.adjustSizeToText()
        label.attemptMoveBy(marge, page.pageSize().height() - 0.6 * marge)
        layout.addItem(label)

        layout.updateBounds()

        # Export
        if os.path.exists(outPath):
            try:
                os.remove(outPath)
                message = str(outPath)
            except Exception as e:
                message = "unable to remove " + str(outPath) + "(" + str(e) + ")"

        exporter = QgsLayoutExporter(layout)

        try:
            exporter.exportToImage(outPath, QgsLayoutExporter.ImageExportSettings())
        except Exception as e:
            pass

        self.iface.messageBar().pushMessage(
            u'Carte25k',
            u"A printlayout has been created (menu Project/Layouts/PrintLayout_PWA)",
            level=Qgis.Success,
            duration=0.5
        )

        self.layoutDoc.close()

    def close_layout_dlg(self):
        self.layoutDoc.close()

        # Load print layout templates from profile template folder to listWidget in plugin dialogue

    # Does a layout already exist
    def layout_exists(self, layout_name):
        lm = QgsProject.instance().layoutManager()
        layouts = []
        for l in lm.layouts():
            layouts.append(l.name())
        if layout_name in layouts:
            return sum(layout_name in s for s in layouts)
        else:
            return 0
    
    def loadTemplates(self):
        self.layoutDoc.listWidget.clear()
        templates_dir = os.path.join(self.plugin_dir, 'layout')

        # Search the templates folder and add files to templates list and sort it
        templates = [f.name for f in os.scandir(templates_dir) if f.is_file()]
        templates.sort()

        # Add all the templates from the list to the listWidget (only add files with *.qpt extension)
        for template in templates:
            filename, extension = os.path.splitext(template)
            if extension == '.qpt':
                self.layoutDoc.listWidget.addItem(filename)

    def layoutLoader(self):
        # Layout Load
        title_text = ""
        layout_name = 'layout_pwa'
        # Call function to generate layout, renaming duplicate layout names
        layout_count = self.layout_exists(layout_name)  # How many layouts with the same name exist already
        if layout_count >> 0:
            name = layout_name.split('_')
            if layout_count >> 1:
                layout_name = '_'.join(name) + '_' + str(layout_count + 1)
            else:
                layout_name += '_2'

        # template_name = self.layoutDoc.listWidget.currentItem().text()
        # Layout Template Name
        template_name = "map_9"
        template_name = str(template_name) + '.qpt'
        template_source = os.path.join(self.plugin_dir, 'layout', template_name)

        """ Generate the layout """
        lm = QgsProject.instance().layoutManager()
        prin_layout = QgsPrintLayout(QgsProject.instance())
        prin_layout.initializeDefaults()

        # Load template file and load it into the layout (l)
        template_file = open(template_source, 'r+', encoding='utf-8')
        template_content = template_file.read()
        template_file.close()
        document = QDomDocument()
        document.setContent(template_content)

        context = QgsReadWriteContext()
        prin_layout.loadFromTemplate(document, context)

        # Give the layout a name (must be unique)
        prin_layout.setName(layout_name)

        # Get current canvas extent and apply that to all maps (items) in layout
        # Replace any text "{{title}}" in any layout label with the dialog Title text
        branch = self.layoutDoc.branch.text()
        cus_name = self.layoutDoc.cus_name.text()
        cus_code = self.layoutDoc.cus_code.text()
        cus_add = self.layoutDoc.cus_add.toPlainText()
        survey_date = self.layoutDoc.survey_date.text()
        survey_by = self.layoutDoc.survey_by.text()

        canvas = iface.mapCanvas()
        for item in prin_layout.items():
            if item.type() == 65639:  # Map
                item.zoomToExtent(canvas.extent())
            if item.type() == 65641:  # Label
                # item.setText(item.text().replace('{{title}}', title_text))
                item.setText(item.text().replace('{{branch}}', branch))
                item.setText(item.text().replace('{{cus_name}}', cus_name))
                item.setText(item.text().replace('{{cus_code}}', cus_code))
                item.setText(item.text().replace('{{cus_add}}', cus_add))
                item.setText(item.text().replace('{{survey_date}}', survey_date))
                item.setText(item.text().replace('{{survey_by}}', survey_by))

        # Add layout to layout manager
        prin_layout.refresh()
        lm.addLayout(prin_layout)
        a_layout = QgsProject.instance().layoutManager().layoutByName(layout_name)
        # Set Map Scale
        map2_scale = 3000

        my_map2 = a_layout.itemById('Map 2')
        my_map2.setScale(float(map2_scale))

        # Open and show the layout in designer
        try:
            self.iface.openLayoutDesigner(prin_layout)
        except:
            oopsBox = QMessageBox()
            oopsBox.setIcon(QMessageBox.Warning)
            oopsBox.setText(self.tr(
                'Ooops. Something went wrong. Trying to open the generated layout ({}) returned errors.'.format(
                    prin_layout.name())))
            oopsBox.setWindowTitle(self.tr('Layout Loader'))
            oopsBox.exec_()

        self.layoutDoc.close()

    def ch_new_tk(self):
        result = check_token_expired(self)
        if result == "Token_Expired":
            message = "New Token Exp"
            self.iface.messageBar().pushMessage("Information  ", message, level=3, duration=3)
            load_new_token(self)
        else:
            # Get config from config.ini
            config = configparser.ConfigParser()
            configpath = os.path.join(self.plugin_dir, 'config.ini')
            config.read(configpath)
            token_new = config.get('settings', 'token_new')
            self.token_new = token_new + "99"
            message = "New Token not Exp"
            self.iface.messageBar().pushMessage("Information  ", message, level=3, duration=3)

    def map_tool_changed(self):

        print("maptoolchanged")
        canvas = self.iface.mapCanvas()
        # QObject.disconnect(canvas, SIGNAL("mapToolSet(QgsMapTool *)"), self.map_tool_changed)
        canvas.unsetMapTool(self.map_tool)
        self.map_tool_action.setChecked(False)
    """
    def meter_tool_changed(self):
        print("metertoolchanged")
        canvas = self.iface.mapCanvas()
        # QObject.disconnect(canvas, SIGNAL("mapToolSet(QgsMapTool *)"), self.map_tool_changed)
        canvas.unsetMapTool(self.map_tool)
        self.meter_tool_action.setChecked(False)
    """
    def showTileForm(self, feature):
        # print(feature.attributes())

        layer = iface.activeLayer()
        if layer:
            activeLayer = layer.name()
            # layerName = layer.name()
            # activeLayer = layerName.split('_')
            if activeLayer == "FIREHYDRANT":
                fire_from(self, feature, activeLayer)
            # elif activeLayer == "DMA_BOUNDARY":
            elif activeLayer == "DMA":
                dma_form(self, feature, activeLayer)
            # elif activeLayer == "PWA_WATERWORKS":
            elif activeLayer == "PWA":
                pwaWaterworks_form(self, feature, activeLayer)
            elif activeLayer == "VALVE":
                valve_form(self, feature, activeLayer)
            elif activeLayer == "PIPE":
                pipe_form(self, feature, activeLayer)
            elif activeLayer == "BLDG":
                bldg_form(self, feature, activeLayer)
            elif activeLayer == "METER":
                meter_form(self, feature, activeLayer)
            elif activeLayer == "LEAKPOINT":
                leak_form(self, feature, activeLayer)
            elif activeLayer == "STRUCT":
                struct_form(self, feature, activeLayer)
            elif activeLayer == "PIPE_SERV":
                pipeServ_form(self, feature, activeLayer)
            elif activeLayer == "FLOW":
                flowMeter_form(self, feature, activeLayer)
            elif activeLayer == "STEP":
                stepTest_form(self, feature, activeLayer)
            else:
                pass

    def addMeterForm(self, feature):
        try:
            layer = iface.activeLayer()
            if str(layer.type()) == "LayerType.Vector":
                from qgis.core import QgsExpressionContextUtils
                layer_name = layer.name()
                layer_name_list = layer_name.split('_')
                if layer_name_list[1] == 'BLDG':
                    buildingTypeId = getTileValue("buildingTypeId", feature)
                    if buildingTypeId is not None:
                        featureId = str(feature['id'])
                        return_mess = print_message_select(
                            "ต้องการเลือกรหัสอาคารที่ใช้น้ำ : " + str(featureId) + " นี้หรือไม่")
                        if return_mess == "ok":
                            QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'featureId', featureId)
                else:
                    find_pipe = layer_name_list[1].find('PIPE')
                    if find_pipe >= 0:
                        typeId = getTileValue("typeId", feature)
                        if typeId is not None:
                            featureId = str(feature['id'])
                            return_mess = print_message_select(
                                "ต้องการเลือกรหัสเส้นท่อที่ใช้น้ำ : " + str(featureId) + " นี้หรือไม่")
                            if return_mess == "ok":
                                QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'featureId',
                                                                             featureId)
            else:
                pass
        except:
            pass

    def map_tool_init(self):
        # this function is called when the map tool icon is clicked
        print("maptoolinit")
        canvas = self.iface.mapCanvas()
        if self.map_tool_action.isChecked():
            # self.meter_tool_action.setChecked(False)
            # when the user activates the tool
            self.prev_tool = canvas.mapTool()
            self.map_tool_action.setChecked(True)
            self.map_tool = IdentifyFeatureTool(canvas)
            # QObject.connect(self.map_tool, SIGNAL("geomIdentified"), self.do_something)
            # self.iface.currentLayerChanged.connect(self.do_something)
            # self.map_tool.geomIdentified.connect(self.showTileForm)
            self.map_tool.geomIdentified.connect(self.showTileForm)
            canvas.setMapTool(self.map_tool)
            # QObject.connect(canvas, SIGNAL("mapToolSet(QgsMapTool *)"), self.map_tool_changed)
            # canvas.mapToolSet().connect(self.map_tool_changed)
        else:
            # when the user deactivates the tool
            # QObject.disconnect(canvas, SIGNAL("mapToolSet(QgsMapTool *)"), self.map_tool_changed)
            canvas.unsetMapTool(self.map_tool)
            print("restore prev tool")
            canvas.setMapTool(self.prev_tool)
    """
    def meter_tool_init(self):
        # this function is called when the map tool icon is clicked
        print("metertoolinit")
        canvas = self.iface.mapCanvas()
        if self.meter_tool_action.isChecked():
            self.map_tool_action.setChecked(False)
            # when the user activates the tool
            self.meter_prev_tool = canvas.mapTool()
            self.meter_tool_action.setChecked(True)
            self.meter_tool = IdentifyFeatureTool(canvas)
            self.meter_tool.geomIdentified.connect(self.addMeterForm)
            canvas.setMapTool(self.meter_tool)
            # QObject.connect(canvas, SIGNAL("mapToolSet(QgsMapTool *)"), self.map_tool_changed)
            # canvas.mapToolSet().connect(self.map_tool_changed)
        else:
            # when the user deactivates the tool
            # QObject.disconnect(canvas, SIGNAL("mapToolSet(QgsMapTool *)"), self.map_tool_changed)
            canvas.unsetMapTool(self.meter_tool)
            print("restore prev tool")
            canvas.setMapTool(self.meter_prev_tool)
    """
    def export_Json(self):
        # Clear Table unsuccessful Add
        self.dockwidget.tableUnsuccessful.setRowCount(0)
        self.dockwidget.tableUnsuccessful.horizontalHeader().setVisible(False)
        self.dockwidget.tableUnsuccessful.clear()
        # Clear Table unsuccessful Edit
        self.dockwidget.tableUnsuccessful_edit.setRowCount(0)
        self.dockwidget.tableUnsuccessful_edit.horizontalHeader().setVisible(False)
        self.dockwidget.tableUnsuccessful_edit.clear()
        add_result = ""
        edit_result = ""
        delete_result = ""
        if len(self.featureid_add) > 0:
            add_result = exportJson_add(self)
        else:
            add_result = "add_success"

        if add_result == "add_success":
            if len(self.featureid_edit) > 0:
                edit_result = exportJson_edit(self)
                print(edit_result)
            else:
                edit_result = "edit_success"

        if edit_result == "edit_success" and add_result == "add_success":
            if len(self.featureid_delete) > 0:
                delete_result = exportJson_delete(self)
            else:
                delete_result = "delete_success"

            # Default after adjust data
            # check_add_status(self)
            # self.dockwidget.radio_add.setChecked(True)

            # self.dockwidget.selectUnsuccessful.setEnabled(1)
        print("result " + str(add_result) + ", " + str(edit_result) + ",  " + str(delete_result))
        self.dlg3.close()
        if add_result == 'add_success' and edit_result == "edit_success" and delete_result == "delete_success":
            self.dlg3.close()
            # self.dockwidget.unsuccess_group.setEnabled(False)
            self.dockwidget.send_dataBtn.setEnabled(0)
            # layer = QgsProject.instance().mapLayersByName("GISTDA Sphere")[0]
            # iface.setActiveLayer(layer)
            print("After add edit delete")
            groupName = "Edit Layers"
            removeGroup(self, groupName)
            group, root = createGroup(self, groupName)
            googleLayer = QgsProject.instance().mapLayersByName("Google Map")
            self.iface.setActiveLayer(googleLayer[0])
            refresh_data(self, root, group)
            print("Before Clone Group " + str(group) + ", " + str(root))
            clone = group.clone()
            root.insertChildNode(0, clone)
            parent = group.parent()
            parent.removeChildNode(group)
            """
            groupName = "Edit Layers"
            removeGroup(self, groupName)
            group, root = createGroup(self, groupName)
            googleLayer = QgsProject.instance().mapLayersByName("Google Map")
            self.iface.setActiveLayer(googleLayer[0])
            refresh_data(self, root, group)
            # self.edit_loaddata()
            """
            after_edit(self)

    def unsuccess_add_data(self):
        row = self.dockwidget.tableUnsuccessful.currentIndex().row()
        colum = self.dockwidget.tableUnsuccessful.columnCount()

        unsuccessful_text = ""
        i = 0
        errType = ""
        while i < colum:
            id_col = self.dockwidget.tableUnsuccessful.horizontalHeaderItem(i).text()
            if id_col == "_temp_id":
                unsuccessful_text = self.dockwidget.tableUnsuccessful.item(row, i).text()
                errType = "topo"
            if id_col == "globalId":
                unsuccessful_text = self.dockwidget.tableUnsuccessful.item(row, i).text()
                errType = "attribute"
            i = i + 1
        unsuccessful_geo = self.dockwidget.tableUnsuccessful.item(row, colum-1).text()

        # unsuccessful_text = self.dockwidget.tableUnsuccessful.item(row, 0).text()
        # unsuccessful_geo = self.dockwidget.tableUnsuccessful.item(row, 1).text()
        goto_error(self, unsuccessful_geo, unsuccessful_text, errType)

    def unsuccess_edit_data(self):
        row = self.dockwidget.tableUnsuccessful_edit.currentIndex().row()
        colum = self.dockwidget.tableUnsuccessful_edit.columnCount()
        print(str(row))
        print(str(colum))

        unsuccessful_text = ""
        i = 0
        errType = ""
        while i < colum:
            id_col = self.dockwidget.tableUnsuccessful_edit.horizontalHeaderItem(i).text()
            print(id_col)
            if id_col == "globalId":
                unsuccessful_text = self.dockwidget.tableUnsuccessful_edit.item(row, i).text()
                errType = "attribute"

            i = i + 1
        print(errType)
        unsuccessful_geo = self.dockwidget.tableUnsuccessful_edit.item(row, colum - 1).text()
        goto_error(self, unsuccessful_geo, unsuccessful_text, errType)

    def setUnsuccessfulAdd(self):
        # Clear Table unsuccessful
        self.dockwidget.radio_edit.setChecked(False)
        self.dockwidget.stackedWidget.setCurrentIndex(0)

    def setUnsuccessfulEdit(self):
        # Clear Table unsuccessful
        self.dockwidget.radio_add.setChecked(False)
        self.dockwidget.stackedWidget.setCurrentIndex(1)

    def goHome(self):
        canvas = self.iface.mapCanvas()
        bounds = self.home_bounds
        rect = zoomto_layer(self, bounds)
        canvas.setExtent(rect)
        canvas.refresh()  # r

    def createNewProject(self):
        self.run()
        retrievePipeProject(self)
        addProjectType(self)
        resetForm(self)
        # self.dlg_project.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.dlg_project.deletePipeProject.setEnabled(False)
        self.dlg_project.updatePipeProject.setEnabled(False)
        self.dlg_project.pipeProjectSave.setEnabled(False)
        self.dlg_project.groupPipeProjectDesc.setEnabled(False)
        self.dlg_project.show()

    def go_to_search(self):
        self.run()
        self.dockwidget.tabWidget.setCurrentIndex(4)

    def go_to_edit(self):
        self.run()
        self.dockwidget.tabWidget.setCurrentIndex(1)

    def fire_form_close(self):
        self.dlg_fire.close()

    def dma_form_close(self):
        self.dlg_dma.close()

    def meter_form_close(self):
        self.dlg_meter.close()

    def leak_form_close(self):
        self.dlg_leak.close()

    def pwaWaterworks_form_close(self):
        self.dlg_pwaWaterworks.close()

    def valve_form_close(self):
        self.dlg_valve.close()

    def pipe_form_close(self):
        self.dlg_pipe.close()

    def bldg_form_close(self):
        self.dlg_bldg.close()

    def struct_form_close(self):
        self.dlg_struct.close()

    def pipeServe_form_close(self):
        self.dlg_pipeServ.close()

    def flowMeter_form_close(self):
        self.dlg_flowMeter.close()

    def stepTest_form_close(self):
        self.dlg_stepTest.close()

    def bldg_moreInfo(self):
        lodCusAddressTile(self)

    def meter_moreInfo(self):
        loadCusAddressMeterTile(self)

    def load_message(self):
        retrieveAllNotification(self)
        if self.dockwidget.currentPage.text() == "1":
            self.dockwidget.previousBtn.setEnabled(False)
        if self.dockwidget.currentPage.text() == "1" and self.dockwidget.lastPage.text() == "1":
            self.dockwidget.nextBtn.setEnabled(False)

    def read_message(self):
        self.dlg_notification.close()
        row = self.dockwidget.notificationTable.currentIndex().row()
        notiTitle = self.dockwidget.notificationTable.item(row, 1).text()
        self.notiId = self.dockwidget.notificationTable.item(row, 0).text()
        self.dockwidget.notificationTable.selectRow(row)
        if "cosmetic" in notiTitle.lower():
            read_messageDlg(self, row)
            self.dockwidget.cosmeticTopic.setText(str(notiTitle))
            self.dockwidget.notiStack.setCurrentIndex(1)
            pass
        else:
            read_messageDlg(self, row)
            self.dlg_notification.setWindowFlags(Qt.WindowStaysOnTopHint)
            self.dlg_notification.show()
        # data = retrieveNotification(self, messageId)
        # data = retrieveNotification(self, self.notiId)
        # topic = data["topic"]
        # print(topic)

    def noti_dlg_close(self):
        self.dlg_notification.close()

    def nextPage(self):
        currentPage = self.dockwidget.currentPage.text()
        currentPage = int(currentPage) + 1
        self.dockwidget.currentPage.setText(str(currentPage))
        loadMessage(self)
        if self.dockwidget.currentPage.text() == self.dockwidget.lastPage.text():
            self.dockwidget.nextBtn.setEnabled(False)
        if self.dockwidget.currentPage.text() != "1":
            self.dockwidget.previousBtn.setEnabled(True)

    def previousPage(self):
        currentPage = self.dockwidget.currentPage.text()
        currentPage = int(currentPage) - 1

        self.dockwidget.currentPage.setText(str(currentPage))
        self.dockwidget.previousBtn.setEnabled(True)
        self.dockwidget.nextBtn.setEnabled(True)

        loadMessage(self)
        if self.dockwidget.currentPage.text() == "1":
            self.dockwidget.previousBtn.setEnabled(False)

    def updateDateTime(self):
        value = self.dockwidget.mDateTimeEdit.dateTime()
        l_date = value.toString("yyyy-MM-dd HH:mm:ssZ")
        self.dlg_flowMeter.dateTimeLine.setText(str(l_date))
    """
    def zoomtoCosmetic(self):
        cosmeticLayerId = self.cosmeticId
        data = retrieveCosmetic(self, cosmeticLayerId)
        geo_text = zoomToCosmeticLayer(self, data)
        # previewCosmeticLayer(self, cosmeticLayerId)
        zoomToPoint(self, geo_text)
        print(str(self.userId))
    """

    def previewJob(self):
        data = retrieveNotification(self, self.notiId)
        cosmeticId = data["detail"]["cosmetic"]["id"]
        self.cosmeticId = cosmeticId
        print(cosmeticId)
        previewCosmeticLayer(self, cosmeticId)

        """ Zoom to Cosmetic layer"""
        data = retrieveCosmetic(self, cosmeticId)
        geo_text = zoomToCosmeticLayer(self, data)
        zoomToPoint(self, geo_text)

        self.dockwidget.acceptJobBth.setEnabled(True)

    def MyToolBars(self):
        """ Create user toolbars """
        self.file.open(QIODevice.ReadOnly)
        datastream = QDataStream(self.file)
        num_childs = datastream.readUInt32()
        for _ in range(0, num_childs):
            item = QTreeWidgetItem()
            item.read(datastream)
            self.bar = None
            DelToolBarIface(item.text(0), self.iface)
            self.bar = self.iface.mainWindow().addToolBar(item.text(0))
            self.restore_item(datastream, item)

        self.file.close()
        return

    def restore_item(self, datastream, _):
        num_childs = datastream.readUInt32()
        for _ in range(0, num_childs):
            child = QTreeWidgetItem()
            child.read(datastream)
            self.bar.addAction(obtainAction(child.text(0), self.iface))
            self.restore_item(datastream, child)

    def getProjectDes(self):
        projectNo = self.dlg_project.listProject.currentText()
        if projectNo != "":
            resetForm(self)
            data = getPipeProject(self, projectNo)
            if data == "notfound":
                message = "Pipe project " + str(projectNo) + " not found description"
                self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
            else:
                putPipeProjectDes(self, data)
                self.dlg_project.deletePipeProject.setEnabled(True)
                self.dlg_project.updatePipeProject.setEnabled(True)
                self.dlg_project.pipeProjectSave.setEnabled(False)

    def pipeProjectClose(self):
        self.dlg_project.close()

    def savePipeProject(self):
        pipeProjectId = str(self.dlg_project.projectId.text())
        projectNo = str(self.dlg_project.projectNo.text())
        """ Validate Form Before Update or Add """
        if validateFormPipeProject(self):
            # Update Pipe Project
            if pipeProjectId != "":
                ppJson = createProjectJson(self)
                result = update_PipeProject(self, pipeProjectId, ppJson)
                if result == "updateSuccess":
                    printMessage = "แก้ไขข้อมูล เลขที่สัญญา/สัญญาการใช้น้ำ " + str(projectNo) + " สำเร็จ"
                    infoMsgBox(printMessage)
                    retrievePipeProject(self)
                    resetForm(self)
                    self.dlg_project.deletePipeProject.setEnabled(False)
                    self.dlg_project.updatePipeProject.setEnabled(False)
                    self.dlg_project.pipeProjectSave.setEnabled(False)
                    self.dlg_project.groupPipeProjectDesc.setEnabled(False)
            # Add Pipe Project
            else:
                projectNo = self.dlg_project.projectNo.text()
                result = getPipeProject(self, projectNo)
                if result == "notfound":
                    printMessage = "เพิ่มข้อมูล เลขที่สัญญา/สัญญาการใช้น้ำ " + str(projectNo) + " สำเร็จ"
                    infoMsgBox(printMessage)
                    ppJson = createProjectJson(self)
                    saveNewPipeProject(self, ppJson)
                    retrievePipeProject(self)
                    resetForm(self)
                    self.dlg_project.deletePipeProject.setEnabled(False)
                    self.dlg_project.updatePipeProject.setEnabled(False)
                    self.dlg_project.pipeProjectSave.setEnabled(False)
                    self.dlg_project.groupPipeProjectDesc.setEnabled(False)
                else:
                    message = "Pipe project " + str(projectNo) + " is duplicate."
                    self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        else:
            printMessage = "ท่านกรอกข้อมูลไม่ครบถ้วน กรุณาตรวจสอบข้อมูลแล้วลองใหม่อีกครั้ง"
            alertMsgBox(printMessage)

    def addPipeProject(self):
        resetForm(self)
        self.dlg_project.listProject.setCurrentIndex(0)
        self.dlg_project.groupPipeProjectDesc.setEnabled(True)
        self.dlg_project.deletePipeProject.setEnabled(False)
        self.dlg_project.updatePipeProject.setEnabled(False)
        self.dlg_project.pipeProjectSave.setEnabled(True)

    def deletePipeProject(self):
        pipeProjectId = str(self.dlg_project.projectId.text())
        projectNo = str(self.dlg_project.projectNo.text())
        if pipeProjectId != "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("ต้องการลบ เลขที่สัญญา/สัญญาการใช้น้ำ " + projectNo + " ใช่หรือไม่")
            msg.setWindowTitle("PWA Message")
            msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            retval = msg.exec_()
            if retval == QMessageBox.Ok:
                result = delPipeProject(self, pipeProjectId)
                if result == "deleteSuccess":
                    printMessage = "ลบข้อมูล เลขที่สัญญา/สัญญาการใช้น้ำ " + str(projectNo) + " สำเร็จ"
                    infoMsgBox(printMessage)
                    retrievePipeProject(self)
                    resetForm(self)
                    self.dlg_project.deletePipeProject.setEnabled(False)
                    self.dlg_project.updatePipeProject.setEnabled(False)
                    self.dlg_project.pipeProjectSave.setEnabled(False)
        else:
            message = "Muse select one pipe project to delete"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)

    def updatePipeProject(self):
        self.dlg_project.groupPipeProjectDesc.setEnabled(True)
        self.dlg_project.pipeProjectSave.setEnabled(True)
        """
        pipeProjectId = str(self.dlg_project.projectId.text())
        if pipeProjectId != "":
            ppJson = createProjectJson(self)
            result = update_PipeProject(self, pipeProjectId, ppJson)
            if result == "updateSuccess":
                retrievePipeProject(self)
                self.dlg_project.deletePipeProject.setEnabled(True)
                self.dlg_project.updatePipeProject.setEnabled(True)
                self.dlg_project.pipeProjectSave.setEnabled(False)
                # resetForm(self)
        else:
            message = "Muse select one pipe project to update"
            self.iface.messageBar().pushMessage("Warning  ", message, level=2, duration=3)
        """
    def tab_changed(self):
        currentTabIndex = self.dockwidget.tabWidget.currentIndex()
        if currentTabIndex == 3:
            # Load pipe project for report
            retrievePipeProject_report(self)

    def onStateChanged(self):
        if self.dockwidget.checkNonpwa.isChecked():
            self.nonpwa = True
        else:
            self.nonpwa = False

    def goToReadMessage(self):
        self.dockwidget.notiStack.setCurrentIndex(0)

    def loadCosmeticCollection(self):
        print("Accept Job edit cosmetic layer")
        cosmeticId = self.cosmeticId
        cosmeticData = retrieveData(self, cosmeticId)
        """ Set cosmeticJson for return """
        self.cosmeticJson = cosmeticData
        """ Update assignUsers action = true"""
        if cosmeticData != "":
            modified_json = updateAcceptStatus(self, cosmeticData)
            updateResult = acceptJob(self, cosmeticId, modified_json)
            if updateResult != "":
                print("Load Cosmetic Collection to edit")
                self.dockwidget.cosmeticCombo.clear()
                data = json.loads(self.collection_json)
                for i in range(len(data['collection'][0]['items'])):
                    datalayer = data['collection'][0]['items'][i]['itemtype']
                    if datalayer == "STRUCT" or datalayer == "FLOW_METER" or datalayer == "PIPE_SERV" or datalayer == "STEP_TEST":
                        pass
                    else:
                        self.dockwidget.cosmeticCombo.addItem(data['collection'][0]['items'][i]['itemtype'])
                self.dockwidget.cosmetic_loadataBtn.setEnabled(True)
                self.dockwidget.cosmeticCombo.setEnabled(True)
            else:
                print("Can not update status cosmetic layer")
        else:
            print("Can not get cosmetic layer")

    def cosmetic_load_edit(self):
        print("load item to edit cosmetic layer")
        groupName = "Edit Layers"
        removeGroup(self, groupName)
        group, root = createGroup(self, groupName)
        googleLayer = QgsProject.instance().mapLayersByName("Google Map")
        self.dockwidget.cosmetic_senddataBtn.setEnabled(True)
        self.iface.setActiveLayer(googleLayer[0])

        loadLayerToEdit(self, root, group)
        clone = group.clone()
        root.insertChildNode(0, clone)
        parent = group.parent()
        parent.removeChildNode(group)

    def cosmetic_send_edit(self):
        print("Send data to check edit")
        jsonFile = ""
        layer = self.iface.activeLayer()
        m_action = "save"
        if layer.isModified() is True:
            m_action = stop_edit(self)
        if m_action == "save":
            add_record, edit_record, delete_record = sumCollectionEdit(self)
            self.dockwidget.cosmeticAddLabel.setText(str(len(add_record)))
            self.dockwidget.cosmeticEditLabel.setText(str(len(edit_record)))
            self.dockwidget.cosmeticDeleteLabel.setText(str(len(delete_record)))

            print("Cosmetic add record : " + str(len(add_record)))
            print("Cosmetic edit record : " + str(len(edit_record)))
            print("Cosmetic delete record : " + str(len(delete_record)))

            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("ต้องการนำส่งข้อมูลนี้หรือไม่")
            msg.setWindowTitle("PWA Message")
            msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            retval = msg.exec_()
            if retval == QMessageBox.Ok:
                if len(add_record) > 0:
                    """ Add Cosmetic """
                    next_df = exportAddCosmetic(self)
                    result_add, geojson_file = exportJson_addCosmetic(self, next_df)
                    jsonFile = modify_add_geojson_cosmetic(self, geojson_file)
                elif len(edit_record) > 0:
                    """ Edit Cosmetic """
                    next_df = exportEditCosmetic(self)
                    result_edit, geojson_file = exportJson_deleteCosmetic(self, next_df)
                    jsonFile = modify_edit_geojson_cosmetic(self, geojson_file)
                elif len(delete_record) > 0:
                    """ Delete Cosmetic """
                    next_df = exportDeleteCosmetic(self)
                    result_delete, geojson_file = exportJson_deleteCosmetic(self, next_df)
                    jsonFile = modify_delete_geojson_cosmetic(self, geojson_file)

                status = updateCosmeticLayer(self, jsonFile)
                self.dockwidget.cosmeticAddLabel.setText("0")
                self.dockwidget.cosmeticEditLabel.setText("0")
                self.dockwidget.cosmeticDeleteLabel.setText("0")
                self.dockwidget.acceptJobBth.setEnabled(0)
                self.dockwidget.cosmetic_loadataBtn.setEnabled(0)
                self.dockwidget.cosmetic_senddataBtn.setEnabled(0)
        # self.dlg3.show()

    def runLayout(self):
        self.layoutDoc = layoutDialog()

        self.layoutDoc.groupBox.setVisible(False)
        # Set close dialog Change Department ween click X
        self.layoutDoc.rejected.connect(self.close_layout_dlg)

        # Set Branch Text
        try:
            branch_report = str(self.branch_text)
        except:
            branch_report = ""

        if branch_report != "":
            branch_report = branch_report.replace('การประปาส่วนภูมิภาค สาขา', '')
        self.layoutDoc.branch.setText(str(branch_report))

        # self.layoutDoc.ok_button.clicked.connect(self.createMap)
        self.layoutDoc.ok_button.clicked.connect(self.layoutLoader)
        self.layoutDoc.cancel_button.clicked.connect(self.close_layout_dlg)

        # Load Template
        self.layoutDoc.loadBtn.clicked.connect(self.loadTemplates)

        self.layoutDoc.selectBtn.clicked.connect(self.layoutLoader)

        self.layoutDoc.show()

    def run(self):
        """Run method that loads and starts the plugin"""
        # Check Plugin Version
        clientVersion = getMetaData(self)
        supportVer = checkPluginVersion(self, clientVersion)


        if supportVer is False:
            alertText = "ปลั๊กอินของท่่านเวอร์ชั้น " + str(clientVersion) + " โปรดปรับปรุงปลั๊กอินให้เป็นเวอร์ชั่นปัจจุบัน"
            alertMsgBox(alertText)

        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dockwidget is None:
                # Set default svg path for symbol
                startup(self)

                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = pwagisDockWidget()
                self.dlg1 = changeDepartmentDialog()
                self.dlg2 = importImageDialog()
                self.dlg3 = confirmEditDialog()
                self.dlg4 = reportDialog()
                self.dlg_fire = fireDialog()
                self.dlg_dma = dmaDialog()
                self.dlg_pwaWaterworks = pwaWaterworksDialog()
                self.dlg_valve = valveDialog()
                self.dlg_pipe = pipeDialog()
                self.dlg_bldg = bldgDialog()
                self.dlg_meter = meterDialog()
                self.dlg_leak = leakDialog()
                self.dlg_notification = notificationDialog()
                self.dlg_struct = structDialog()
                self.dlg_pipeServ = pipeServeDialog()
                self.dlg_flowMeter = flowMeterDialog()
                self.dlg_stepTest = stepTestDialog()
                self.dlg_project = projectDialog()

                # Set close dialog Change Department ween click X
                self.dlg1.rejected.connect(self.changeDepartpop_close)

                QgsProject.instance().clear()
                # Set Forgot password link to external
                self.dockwidget.forgotpassword.setText("<a style='color:blue; text-decoration:none;' "
                                                       "href='https://pwa.co.th/' target='_blank'>ลืมรหัสผ่าน</a>")

                # Get config from config.ini
                config = configparser.ConfigParser()
                configpath = os.path.join(self.plugin_dir, 'config.ini')
                self.config = config
                self.configpath = configpath
                config.read(configpath)
                self.host = config.get('settings', 'host')
                self.maxfeature = config.get('settings', 'maxfeature')
                email = config.get('settings', 'username')
                password = config.get('settings', 'password')
                self.currentbranch = config.get('settings', 'currentbranch')
                self.currentdistrict = config.get('settings', 'currentdistrict')
                self.baseUrl = config.get('settings', 'baseUrl')
                self.nonpwa = config.get('settings', 'nonpwa')

                # Check NonPWA
                self.dockwidget.checkNonpwa.stateChanged.connect(self.onStateChanged)
                self.dockwidget.checkNonpwa.setChecked(False)

                # Set Visible
                self.dockwidget.tabWidget.setTabVisible(2, False)  # Import_TAB
                self.dockwidget.tabWidget.setTabVisible(6, True)  # Login_TAB
                self.dockwidget.tabWidget.setTabVisible(7, False)  # Log_TAB
                # self.dockwidget.tabWidget.setTabVisible(8, False)  # Temp_TAB
                # self.dockwidget.mGroupBox.hide()
                self.dockwidget.collectionID_temp.setVisible(False)  # Edit CollectionID Temp

                self.dockwidget.plainTextEdit_3.setVisible(False)  # Login
                """
                self.dockwidget.pushButton.setVisible(False)  # Login
                self.dockwidget.pushButton_2.setVisible(False)  # Login
                self.dockwidget.tool_edit.setVisible(False)
                self.dockwidget.lineEdit_2.setVisible(False)
                self.dockwidget.checnToken.setVisible(False)
                """

                self.dockwidget.select_dbBtn.setEnabled(0)
                self.dockwidget.send_dataBtn.setEnabled(1)
                self.dockwidget.deleteDataBtn.setEnabled(0)

                self.dockwidget.logoutBtn.setEnabled(0)
                self.dockwidget.changeDepartmentBnt.setEnabled(0)
                
                # self.dockwidget.username.setText(email)
                # self.dockwidget.password.setText(password)
                self.dockwidget.loginBtn.clicked.connect(self.logins)
                self.dockwidget.logoutBtn.clicked.connect(self.logout)

                self.dockwidget.mGroupBox_2.hide()                
                self.dockwidget.mGroupBox_4.hide()
                self.dockwidget.mGroupBox_5.hide()
                self.dockwidget.mGroupBox_6.hide()

                # Set Current Tab To login TAB
                self.dockwidget.tabWidget.setCurrentIndex(6)
                # Set Only Login TAB Enable other TAB Disable
                self.dockwidget.tabWidget.setTabEnabled(0, False)
                self.dockwidget.tabWidget.setTabEnabled(1, False)
                self.dockwidget.tabWidget.setTabEnabled(2, False)
                self.dockwidget.tabWidget.setTabEnabled(3, False)
                self.dockwidget.tabWidget.setTabEnabled(4, False)
                self.dockwidget.tabWidget.setTabEnabled(5, False)

                self.dockwidget.costmetic_checkBox.setVisible(False)

                # Set Password fild to ...
                self.dockwidget.password.setEchoMode(2)
                
                self.dockwidget.deleteDataBtn.clicked.connect(self.deleteData_pop)
                self.dlg3.editCancelBtn.clicked.connect(self.deletepop_close)

                self.dockwidget.changeDepartmentBnt.clicked.connect(self.changeDepart_pop)
                self.dlg1.chageDepartmentCloseBnt.clicked.connect(self.changeDepartpop_close)

                self.dlg1.choseDepartmentBtn.clicked.connect(self.choseDepartment)

                self.dlg1.districtCombo.currentTextChanged.connect(self.get_branch_list)

                self.dockwidget.importImageBtn.clicked.connect(self.importImage_pop)
                self.dlg2.tranferDataBtn.clicked.connect(self.importImagepop_close)

                self.dockwidget.send_dataBtn.setEnabled(0)
                
                self.dockwidget.resultTable.setEditTriggers(QAbstractItemView.NoEditTriggers)
                # loadResultToTable(self)

                """ Search Data When Click Search Button"""
                self.dockwidget.searchBtn_2.clicked.connect(self.searchData)    # Search on Text Edit
                self.dockwidget.searchBtn_3.clicked.connect(self.searchData)    # Search on DateTime
                self.dockwidget.searchBtn_4.clicked.connect(self.searchData)    # Search on Combo
                self.dockwidget.searchBtn_5.clicked.connect(self.searchData)    # Search for pipe size and type
                
                # self.dockwidget.resultTable.doubleClicked.connect(self.get_data_row)
                # self.dockwidget.resultTable.clicked.connect(self.more_cell)
                self.dockwidget.resultTable.clicked.connect(self.get_data_row)
                
                self.dockwidget.datalayercombo.currentTextChanged.connect(self.selectDataLayer)
                self.dockwidget.attributeCombo.currentTextChanged.connect(self.clearSearchText)
                # When pipe type change load pip size reference by pip type
                self.dockwidget.attributeCombo_3.currentTextChanged.connect(self.selectPipeType)

                # Reset Search Text By Click Rest Buton in Search TAB
                self.dockwidget.restBtn_2.clicked.connect(self.reset_search)
                self.dockwidget.restBtn_3.clicked.connect(self.reset_search)
                self.dockwidget.restBtn_4.clicked.connect(self.reset_search)
                self.dockwidget.restBtn_5.clicked.connect(self.reset_search)

                """ Edit TAB """
                # Edit Tab When DataLayer combo change
                self.dockwidget.edit_datalayer_combo.currentTextChanged.connect(self.edit_DataLayer_change)
                # Edit Tab When Click load data
                self.dockwidget.edit_loadataBtn.clicked.connect(self.edit_loaddata)
                # Edit Tab When Click open db file
                self.dockwidget.select_dbBtn.clicked.connect(self.edit_load_db_file)
                # Edit Tab When Click send db
                self.dockwidget.send_dataBtn.clicked.connect(self.edit_send_db_file)
                # Edit Tab When Click Add
                self.dockwidget.add_Btn.clicked.connect(self.edit_export_add)
                # Edit Tab When Click edit
                self.dockwidget.edit_Btn.clicked.connect(self.edit_export_edit)
                # Edit Tab When Click delete
                self.dockwidget.delete_Btn.clicked.connect(self.edit_export_delete)
                # Edit Tab db_label
                self.dockwidget.db_label.setText("")
                # Temp Export JSON
                self.dlg3.editConfirmBtn.clicked.connect(self.export_Json)
                # Edit RadioButton toggled
                # self.dockwidget.selectUnsuccessful.currentTextChanged.connect(self.setUnsuccessfulTable)
                self.dockwidget.radio_add.toggled.connect(self.setUnsuccessfulAdd)
                self.dockwidget.radio_edit.toggled.connect(self.setUnsuccessfulEdit)

                # Edit RadioButton Check
                self.dockwidget.radio_add.setChecked(False)
                self.dockwidget.radio_add.setChecked(False)

                # Edit Set visible add delete update button
                self.dockwidget.add_Btn.setVisible(False)
                self.dockwidget.edit_Btn.setVisible(False)
                self.dockwidget.delete_Btn.setVisible(False)

                # Edit Set Table Add Unscuucess
                self.dockwidget.tableUnsuccessful.clicked.connect(self.unsuccess_add_data)
                self.dockwidget.tableUnsuccessful_edit.clicked.connect(self.unsuccess_edit_data)

                # Edit Set Disable radio group unsuccessful
                # self.dockwidget.unsuccess_group.setEnabled(0)
                # self.dockwidget.selectUnsuccessful.setEnabled(0)

                """ Report Tab """
                # Report Tab When Click show report
                self.dockwidget.show_reportBtn.clicked.connect(self.show_report)
                self.dockwidget.report_downloadBtn.clicked.connect(self.download_report)
                self.dockwidget.report_id_select.currentTextChanged.connect(self.reportChange)

                """ Home Button """
                # Set home button disable
                self.dockwidget.homeBtn.setEnabled(0)
                self.dockwidget.homeBtn.clicked.connect(self.goHome)

                """ Tile Form Dialog """
                self.dlg_fire.okBtn.clicked.connect(self.fire_form_close)
                self.dlg_dma.okBtn.clicked.connect(self.dma_form_close)
                self.dlg_meter.okBtn.clicked.connect(self.meter_form_close)
                self.dlg_pwaWaterworks.okBtn.clicked.connect(self.pwaWaterworks_form_close)
                self.dlg_valve.okBtn.clicked.connect(self.valve_form_close)
                self.dlg_pipe.okBtn.clicked.connect(self.pipe_form_close)
                self.dlg_bldg.okBtn.clicked.connect(self.bldg_form_close)
                self.dlg_bldg.moreinfo.clicked.connect(self.bldg_moreInfo)
                self.dlg_meter.okBtn.clicked.connect(self.meter_form_close)
                self.dlg_meter.moreinfo.clicked.connect(self.meter_moreInfo)
                self.dlg_leak.okBtn.clicked.connect(self.leak_form_close)
                self.dlg_struct.okBtn.clicked.connect(self.struct_form_close)
                self.dlg_pipeServ.okBtn.clicked.connect(self.pipeServe_form_close)
                self.dlg_flowMeter.okBtn.clicked.connect(self.flowMeter_form_close)
                self.dlg_stepTest.okBtn.clicked.connect(self.stepTest_form_close)

                # self.dlg_flowMeter.installedDate.dateTimeChanged.connect(self.updateDateTime)

                """ Get Bldg Id in meter """

                """ Notification Tab """
                self.dockwidget.notiStack.setCurrentIndex(0)
                self.dlg_notification.notificationCloseBtn.clicked.connect(self.noti_dlg_close)
                self.dockwidget.notificationTable.setSelectionBehavior(QTableWidget.SelectRows)
                self.dockwidget.loadMessageBtn.clicked.connect(self.load_message)

                self.dockwidget.readMessage.clicked.connect(self.goToReadMessage)

                self.dockwidget.loadMessageBtn.setVisible(True)
                notificationIconFile = "reload-icon.png"
                notificationIcon = os.path.join(self.plugin_dir, "icon", notificationIconFile)
                self.dockwidget.loadMessageBtn.setIcon(QIcon(notificationIcon))

                self.dockwidget.notificationTable.clicked.connect(self.read_message)

                pic = "reload-icon.png"
                picIcon = os.path.join(self.plugin_dir, "icon", pic)
                self.dockwidget.nortificationLabel.setPixmap(QPixmap(picIcon))
                self.dockwidget.nortificationLabel.setVisible(False)

                self.dockwidget.nextBtn.clicked.connect(self.nextPage)
                self.dockwidget.previousBtn.clicked.connect(self.previousPage)
                self.dockwidget.previousBtn.setEnabled(False)

                # Preview and Zoom to Cosmetic Layers
                self.dockwidget.previewBtn.clicked.connect(self.previewJob)

                self.dockwidget.groupCosmetic.setVisible(True)

                """ Edit Cosmetic Layer """
                self.dockwidget.acceptJobBth.clicked.connect(self.loadCosmeticCollection)
                self.dockwidget.cosmetic_loadataBtn.clicked.connect(self.cosmetic_load_edit)
                self.dockwidget.cosmetic_senddataBtn.clicked.connect(self.cosmetic_send_edit)

                """ ProjectDialog """
                self.dlg_project.getProjectBtn.clicked.connect(self.getProjectDes)
                self.dlg_project.pipeProjectClose.clicked.connect(self.pipeProjectClose)
                self.dlg_project.pipeProjectSave.clicked.connect(self.savePipeProject)
                self.dlg_project.addPipeProject.clicked.connect(self.addPipeProject)
                self.dlg_project.deletePipeProject.clicked.connect(self.deletePipeProject)
                self.dlg_project.updatePipeProject.clicked.connect(self.updatePipeProject)

                self.dockwidget.projectId.setVisible(False)

                # Tab Report Click
                self.dockwidget.tabWidget.currentChanged.connect(self.tab_changed)

                # Set Plugin Version
                self.dockwidget.setWindowTitle("PWAGIS (Version : " + str(clientVersion) + ")")

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            # self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)  # Right
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)  # Left
            self.dockwidget.show()


class IdentifyFeatureTool(QgsMapToolIdentify):
    def __init__(self, canvas):
        QgsMapToolIdentify.__init__(self, canvas)

    # geomIdentified = pyqtSignal(['QgsVectorLayer', 'QgsFeature'])
    geomIdentified = pyqtSignal(['QgsFeature'])
    # gemIdentified = pyqtSignal(['str'])

    def canvasReleaseEvent(self, mouseEvent):
        print("canvasReleaseEvent")
        # get features at the current mouse position
        # results = self.identify(mouseEvent.x(), mouseEvent.y(), self.TopDownStopAtFirst, self.VectorTileLayer)
        results = self.identify(mouseEvent.x(), mouseEvent.y(), self.TopDownStopAtFirst)
        if len(results) > 0:
            # print(str(results))
            # signal that a feature was identified
            # self.emit(SIGNAL("geomIdentified"), results[0].mLayer, results[0].mFeature)
            # self.geomIdentified.emit(results[0].mLayer, results[0].mFeature)
            self.geomIdentified.emit(results[0].mFeature)

